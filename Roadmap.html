<!DOCTYPE html>
<html lang="en">
  <head>

    <!-- Basic Page Needs
    ================================================== -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
     <title>Roadmap</title>

    <!-- Mobile Specific Metas
    ================================================== -->
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Favicon -->
    <link rel="shortcut icon" type="image/png" href="img/favicon.jpg"/>

    <!-- CSS
    ================================================== -->       
    <!-- Bootstrap css file-->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <!-- Font awesome css file-->
    <link href="css/font-awesome.min.css" rel="stylesheet">
    <!-- Superslide css file-->
    <link rel="stylesheet" href="css/superslides.css">
    <!-- Slick slider css file -->
    <link href="css/slick.css" rel="stylesheet"> 
    <!-- smooth animate css file -->
    <link rel="stylesheet" href="css/animate.css">  
    <!-- Elastic grid css file -->
    <link rel="stylesheet" href="css/elastic_grid.css"> 
    <!-- Circle counter cdn css file -->
    <link rel='stylesheet prefetch' href='css/jquery.circliful.css'>    
    <!-- Default Theme css file -->
    <link id="orginal" href="css/themes/eucalyptus-theme.css" rel="stylesheet">
    <!-- Main structure css file -->
    <link href="style.css" rel="stylesheet">

   
    <!-- Google fonts -->
    <link href='css/opensans.css' rel='stylesheet' type='text/css'>
    <link href='css/varela.css' rel='stylesheet' type='text/css'>
    <link href='css/montserrat.css' rel='stylesheet' type='text/css'>

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  
    <style>
    .custom-badge {
        background:#26A65B;
        font-size:20px;
    }
    .custom-badge:hover{
        background:#000000;
    }

    .custom-panel{
      background:#dff0d8;
      border-radius:4px;
      padding:2px;
      height:90px;
    }
    .custom-panel2{
      background:#dff0d8;
      border-radius:4px;
      padding:2px;
    }
    .well{
      height:130px;

    }
  
    </style>


  </head>
  <body>
   
  <!-- BEGIN PRELOADER -->
    <div id="preloader">
      <div id="status">&nbsp;</div>
    </div>
    <!-- END PRELOADER -->   

  
    <!--=========== BEGIN HEADER SECTION ================-->
    <header id="header">
      <!-- BEGIN MENU -->
      <div class="menu_area">
        <nav class="navbar navbar-default navbar-fixed-top past-main" role="navigation"> 
          <div class="container">
          <div class="navbar-header">
            <!-- FOR MOBILE VIEW COLLAPSED BUTTON -->
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            <!-- LOGO -->

            <!-- TEXT BASED LOGO -->
            <a class="navbar-brand" href="index.html">eXpOS<span>NITC</span></a>
            
                              
          </div>
          <div id="navbar" class="navbar-collapse collapse">
            <ul id="top-menu" class="nav navbar-nav navbar-right main_nav">
              <li><a href="./index.html">Home</a></li>
              <li><a href="./documentation.html" target="_blank">Documentation</a></li> 
              <li><a href="./Roadmap.html" target="_blank">Roadmap</a></li>
               <li><a href="faq.html" target="_blank">FAQ</a></li>
              <li><a href="About_us.html" target="_blank">About Us</a></li>                                     
            </ul>           
          </div>
          </div>     
        </nav>  
      </div>
      <!-- END MENU -->

      
    </header>
		<!--=========== End HEADER SECTION ================--> 
      
    <!--=========== Intoduction Section Begining ===============-->
    <!--heading of the page---->
    <div class="container" style="margin-top: 80px;">
      
      <h1>Roadmap</h1>
    </div>           

    <!-- Arrow to top section  -->

    <div class="up grid col-one-third" style="float:right;position: fixed;bottom: 10vh;right: 2vw;">
      <a href="#navtop" title="Go back up"> <span style="color:grey">Top &uarr;</span></a>
    </div>


    <section id="about" style="text-align:justify">
      <div class="container">
        <div class="row">
          <div class="col-lg-12 col-md-12">
            <div class="heading">
              <div>
                <h2 id="navtop">Using the Roadmap</h2>
                <br>
                <br>
                <p>This roadmap is divided into stages. Each stage is to be done in sequential order. 
                You will build eXpOS incrementally. Links are provided throughout the document for further
                 reference. There are two kinds of links. The contents of the <b style="color:#26A65B">important
                  links</b> must be read immediately before proceeding with the roadmap. 
                  The <span style="color:#26A65B">informative links</span> may be clicked for more information 
                  about a particular concept. However this information may not be necessary at that point and 
                  you may proceed with the roadmap without visiting these links.</p>
              
              <!--
                <div class="container-fluid">
                <div class="row-fluid">
                
                <div class="col-sm-3 well">
                <div class="text-center custom-panel" id="stage1">
                <span class="label custom-badge blink"  id="stage1">1</span>
                <h4>Setting up the System</h4>
                </div>
                </div>

                <div class="col-sm-3 well">
                <div class="text-center custom-panel" id="stage2">
                <span class="label custom-badge" id="stage2">2</span>
                <h4>Understanding the File System</h4>
                </div>
                </div>
                
                <div class="col-sm-3 well">
                <div class="text-center custom-panel" id="stage3">
                <span class="label custom-badge" id="stage3">3</span>
                <h4>Bootstrap Loader</h4>    
                </div>
                </div>

                <div class="col-sm-3 well">
                <div class="text-center custom-panel" id="stage4">
                <span class="label custom-badge" id="stage4">4</span>
                <h4>Learning the SPL Language</h4>                
                </div>
                </div>

                <div class="col-sm-3 well">
                <div class="text-center custom-panel" id="stage5">
                <span class="label custom-badge" id="stage5">5</span>
                <h4>Debugging in Kernel mode</h4>                
                </div>
                </div>

                <div class="col-sm-3 well">
                <div class="text-center custom-panel" id="stage6">
                <span class="label custom-badge" id="stage6">6</span>
                <h4>Running a User program</h4>                
                </div>
                </div>
                
                <div class="col-sm-3 well">
                <div class="text-center custom-panel" id="stage7">
                <span class="label custom-badge" id="stage7">7</span>
                <h4>Interrupts</h4>                
                </div>
                </div>
                
                <div class="col-sm-3 well">
                <div class="text-center custom-panel" id="stage8">
                <span class="label custom-badge" id="stage8">8</span>
                <h4>Creating a data file</h4>                
                </div>
                </div>
                
                <div class="col-sm-3 well">
                <div class="text-center custom-panel" id="stage9">
                <span class="label custom-badge" id="stage9">9</span>
                <h4>Opening and Reading a data file</h4>                
                </div>
                </div>

                
                </div>
                </div>


                  <!--========= Stage descrptions starts here ==========-->

                  <div class="panel-group" id="accordion">
                    <div class="panel panel-default">

                      <!-- Stage 1 -->

                      <div class="panel-heading" id="list_stage1">
                        <h4 class="panel-title">
                          <a data-toggle="collapse"  href="#collapse1">
							  <span class="fa fa-check-square-o"></span>Stage 1 : Setting up the System </a>
                        </h4>
                      </div>

                      <div id="collapse1" class="panel-collapse collapse">
                        <div class="panel-body">

                          <!-- Begin Learning Objectives-->
                          <div class="container col-md-12">
                          <div class="section_area">
                          <ul class="list-group">
                           <li class="list-group-item" style="background:#dff0d8">
                            <span class="fa fa-book"></span> &nbsp; <a data-toggle="collapse"  href="#lo1">Learning Objectives</a>
                            <div id="lo1" class="panel-collapse expand">
                            <span class="fa fa-hand-o-right"></span>&nbsp;&nbsp; At the end of this experiment, you
                            will learn how to set up the environment to build eXpOS.                                     
                                     
                            </div>
                          </li>
                          </ul>
                          </div>
                          </div>
                          <!-- End Learning Objectives-->

		<div style="font-size:15px">
                  <ol><br>
                    <li> Download the complete eXpOS package from <a href="https://github.com/eXpOSNitc/eXpOSNitc.github.io/raw/master/package/expos.tar.gz" download>here</a>.</li>
                    <li> Copy the tar file to your home directory. 
                    <pre>cp expos.tar.gz $HOME/<br>cd $HOME</pre></li>
                    <li> Extract the contents using the command. 
                    <pre>tar -xvf expos.tar.gz </pre>
                    Now you will have a directory <tt>myexpos</tt> in your home drectory, with all components required for building your own eXpOS.</li>
                    <li> Install libreadline-dev package <pre>sudo apt-get install libreadline-dev </pre></li>
                    <li> Make sure all the prerequisites which include <b>gcc</b>, <b>flex/lex</b> and <b>bison/yacc</b> are installed. 
                    In Ubuntu/Debian systems, use <b>apt</b> to install flex and bison.
                    <pre>sudo apt-get install flex bison </pre></li>  
                    <li> Change directory to <tt>myexpos</tt> directory.
                    <pre>cd $HOME/myexpos </pre> </li>  
                    <li> Make to build all the components.
                    <pre>make </pre></li>          
                  </ol>
                </div>

                          <p>
                            After the setting up of the system is done correctly the following directories will be created. 
                          </p> 
                          
                          <div><img src="./img/xsm_folders.png"></div>
                          <br/>

                          <p><b style="color:#26A65B">Assignment : </b> Read and understand the <a href="os_spec-files/eXpFS.html" target="_blank">Filesystem (eXpFS) Specification</a> and <a href="./support_tools-files/xfs-interface.html" target="_blank">XFS-Interface Specification</a> (interface between the UNIX System and eXpFS)</p>

                          </div>
                      </div>

                      <!-- Stage 2 -->

                      <div class="panel-heading" id="list_stage2">
                        <h4 class="panel-title">
                          <a data-toggle="collapse"  href="#collapse2"><span class="fa fa-check-square-o"></span>Stage 2 : Understanding the Filesystem  </a>
                        </h4>
                      </div>

                      <div id="collapse2" class="panel-collapse collapse">
                        <div class="panel-body">

                        <!-- Begin Learning Objectives-->
                          <div class="container col-md-12">
                          <div class="section_area">
                          <ul class="list-group">
                           <li class="list-group-item" style="background:#dff0d8">
                            <span class="fa fa-book"></span> &nbsp; <a data-toggle="collapse"  href="#lo2">Learning Objectives</a>
                            <div id="lo2" class="panel-collapse expand">
                            <ul>
                              <li><span class="fa fa-hand-o-right"></span>&nbsp;&nbsp; Load/retrieve data and executable files from/to your host (Unix) system into the XSM disk.</li>
                              <li><span class="fa fa-hand-o-right"></span>&nbsp;&nbsp; Explain the disk data structures of the XFS file system - INODE table, disk free list and root file.</li>
                              <li><span class="fa fa-hand-o-right"></span>&nbsp;&nbsp; Find out the data blocks into which a data/executable file is stored in the XSM disk by examining  the INODE table and root file.</li>
                            </ul>                                  
                                     
                            </div>
                          </li>
                          </ul>
                          </div>
                          </div>
                          <!-- End Learning Objectives-->

                      

                            
                          <p>
                            The <a href="os_spec-files/eXpFS.html" target="_blank"><b>eXperimental Filesystem (eXpFS)</b></a> is a simulated filesystem. A UNIX file named "disk.xfs" simulates the <a href="./arch_spec-files/machine_organisation.html" target="_blank"><b>hard disk</b></a> of the XSM machine. Building eXpOS begins with understanding the underlying filesystem (eXpFS) and its interface <a href="./support_tools-files/xfs-interface.html" target="_blank">(xfs-interface)</a> to the host (UNIX) environment. The xfs-interface is used for transferring files between your linux system and the xsm disk.
                            </p>
                            <br>
                            <figure><img src="img/xfs-interface.png" style="display:block;margin-left:auto;margin-right:auto"></img>
                            <figcaption style="text-align:center">Schematic interface between linux system and XSM disk</figurecaption>
                            </figure>
                            <br>
                            <i> In this stage, you will create a text file and load it to the XFS disk using xfs-interface.</i>
                            <br/><br/>
			
                          <ol style="list-style-type:decimal;margin-left:2px">
                            <li>
                              Run the XFS Interface<br><br>
                              <div>
                                <pre>cd $HOME/myexpos/xfs-interface
./xfs-interface</pre>
                              </div>
                              This will take you to the xfs-interface prompt. 
                            </li>
                            <br/>
                      
                            <li>
                              Start by formatting the disk to the eXpOS file system format in the XFS interface using <b>fdisk</b> command. <br/> <br/> 
                              The <i>fdisk</i> command converts the raw disk into the filesystem format recognised by the eXpOS operating system. It initialises the disk data structures such as <a href="http://exposnitc.github.io/os_design-files/disk_ds.html" target="_blank">disk free list, inode table, user table and root file </a> .<br/></br>
                              Type the following commands in the xfs-interface prompt.
                              <br><br>
                              <div> 
                                <pre># fdisk 
# exit</pre>
                              </div>

                              You will be back in the UNIX shell and a file named <b>disk.xfs</b> is created in the location <b>$HOME/myexpos/xfs-interface/</b>. This UNIX file simulates the hard disk of the XSM machine. The disk is formatted to eXperimental File System (eXpFS) (see <a href="os_spec-files/eXpFS.html" target="_blank"> eXpFS Specification</a>). <br/> <br/>

                              The XSM machine's disk is a sequence of 512 blocks, each block capable of holding
                              512 words (see <a href="os_implementation.html" target="_blank">Disk Organization</a>).  The second block of the formatted disk contains a disk free list which is explained below.
                            </li>
                            <br/>
                            <li>
                              The <a href="os_design-files/disk_ds.html#disk_free_list" target="_blank">Disk Free List</a> in XFS is a data structure which keeps track of used and unused blocks in the disk. An unused block is indicated by 0 and a used block is indicated by 1. Check the contents of the Disk Free List after formatting the disk. Use the <b>df</b> command to view the Disk Free List (stored in disk block number 2). The output will be as follows: 
                              <br><br>
                              <div>   
                                <pre>
0    -   1  
1    -   1  
2    -   1  
3    -   1  
4    -   1  
5    -   1  
6    -   1  
7    -   1  
8    -   1  
9    -   1  
10   -   1  
11   -   1  
12   -   1  
13   -   1  
14   -   1  
15   -   1  
16   -   1  
17   -   1  
18   -   1  
19   -   1
20   -   1
21   -   1
22   -   1
23   -   1
24   -   1
25   -   1
.
.
No of Free Blocks = 443
Total No of Blocks = 512</pre>
                              </div>
                              The first 69 blocks (blocks 0 to 68) are reserved for <a href="./os_design.html"  target="_blank">Disk Structures</a>, <a href="./os_design.html"  target="_blank">OS routines</a>, <a href="./os_design-files/misc.html#shell"  target="_blank">Shell Code</a>, <a href="./os_design-files/misc.html#idle"  target="_blank">Idle Code</a> and <a href="http://exposnitc.github.io/os_design-files/misc.html#login" target="_blank">INIT program</a> (see <a href="os_implementation.html" target="_blank">Disk Organization)</a>. Hence it is marked as 1 (used) and the remaining entries for blocks 69 to 511 are 0 (unused). 
                            </li>

                            <br>
                            <li>Create a file in your UNIX machine with sample data. A sample data file is given below:
                              <br><br>
                              <div>
                                <pre>There is a place where the sidewalk ends
And before the street begins,
And there the grass grows soft and white,
And there the sun burns crimson bright,
And there the moon-bird rests from his flight
To cool in the peppermint wind.</pre>
                              </div>
                              Save the file as <b>$HOME/myexpos/sample.dat</b>
                            </li>

                            <br>
                            <li> Load this data file <tt>($HOME/myexpos/sample.dat)</tt> to the XFS disk from your UNIX machine.  This can be done by the following commands:
                              <br><br>
                              <div> 
                                <pre>cd $HOME/myexpos/xfs-interface
./xfs-interface</pre>
                              </div>
                              This will take you to the xfs-interface prompt. Type the following commands.
                              <br><br>
                              <div> 
                                <pre># load --data $HOME/myexpos/sample.dat</pre>
                              </div>
                              This will load the file to the XFS disk and the following updations happen in disk data structures :
                              <ol style="list-style-type:lower-roman;margin-left:60px">
                                <li>
                                  A disk block will be allocated for the file (as <tt>sample.dat</tt> contains less than 512 words) and corresponding to this allocated block (here block 69 - this is because the 1<sup>st</sup> free block is allocated by the allocator), an entry will be marked as 1 (used) in the <a href="os_design-files/disk_ds.html#disk_free_list" target="_blank">Disk Free List</a>.
                                </li>
                                <li>
                                  An entry in the <a href="os_design-files/disk_ds.html#inode_table"  target="_blank"> Inode Table</a> will be created for this file. Inode Table contains information such as the file type, file name, file size, userid, permission and the block numbers of the data blocks of the file. The <a href="http://exposnitc.github.io/os_spec-files/multiuser.html" target="_blank">owner</a> of data files loaded through <i>xfs-interface</i> is the <i>root</i>. Userid is the index of the user entry in the <a href="http://exposnitc.github.io/os_design-files/disk_ds.html#user_table">User Table</a>. The userid of <i>root</i> is 1 and hence the userid field in the <i>inode table</i> is set to 1 for all data files loaded through the <i>xfs interface</i>. The <a href="http://exposnitc.github.io/os_spec-files/multiuser.html" target="_blank">permission</a> is set to open(1). Note that any file in eXpFS file system is permitted to have a maximum of four data blocks.
                                </li>
                                <li>
                                  An entry for this file will be made in the <a href="os_design-files/disk_ds.html#root_file"  target="_blank">Root File</a> also.
                                </li>
                              </ol>
                              <br>
                              Before proceeding further you must be clear about  <a href="os_spec-files/eXpFS.html" target="_blank"><b>eXpFS (eXperimental File System)</b></a>. In the following steps we will see the above mentioned updations.
                            </li> 

                            <br>
                            <li> Find out the block numbers of the Data Blocks corresponding to the loaded file. Use the <b>copy</b> command to copy the <i>Inode Table</i>(Inode Table is stored in disk blocks 3 and 4) to a UNIX file (say <tt>$HOME/myexpos/inode_table.txt</tt>).
                            <br><br>
                            <div>
                              <pre># copy 3 4 $HOME/myexpos/inode_table.txt
# exit</pre>
                            </div>

                            <code>Note: </code> The Inode table occupies only the first 960 words (60 entries, each of size 16 words) in the disk blocks 3 and 4. <a href="./os_design-files/disk_ds.html#user_table" target="_blank">User table </a>occupies the next 32 words (16 entries, each of size 2 words) and the last 32 words are reserved for future use. (You will learn about User Table later on).
                            
                            <br/>

                            <br>
                            Now check the Inode table entry for the file <tt>sample.dat</tt> in the UNIX file <tt>inode_table.txt</tt> and find the block numbers of its data blocks. The contents of the file <tt>inode_table.txt</tt> will be as follows: <br><br>
                            <div>
                              <pre>
1
root
512
-1
-1
-1
-1
-1
5
-1
-1
-1
-1
-1
-1
-1
2
sample.dat
512
-1
-1
-1
-1
-1
69
-1
-1
-1
-1
-1
-1
-1
-1
.
.
.

                              </pre>


                              <code>Note: </code> Instead of using the <tt>copy</tt> command you can use <a href="./support_tools-files/xfs-interface.html#dump" target="_blank"><tt>dump</tt></a> command provided by the XFS interface to directly copy the disk data structures (inode table, root file) to the UNIX machine as shown below. 

                              <pre># dump --inodetable</pre>

                              This will write the contents of the inodetable into the file $HOME/myxos/xfs-interface/inodetable.txt
                            </div>
                            

                            </li>

                            <br>
                            <li> Now check the contents of the disk free list and verify that the entry for the 69<sup>th</sup> block is marked as used. This corresponds to the Data Block 1 of <tt>sample.dat</tt>. 
                            </li>
                            
                            <br>
                            <li>
                              Copy the data blocks from the XFS disk and display it as a UNIX file <tt>$HOME/myexpos/data.txt</tt>. 
                              <br><br>
                              <div>
                                <pre># copy 69 69 $HOME/myexpos/data.txt</pre>
                              </div>    
                              You will get back the contents of the file <tt>$HOME/myexpos/sample.dat</tt> in <tt>$HOME/myexpos/data.txt</tt>. However in <tt>$HOME/myexpos/data.txt</tt>, each word is displayed in a line because a word in XFS is 16 characters long. Sample <tt>data.txt</tt> file is shown below.
                              <br><br>
                              <div>
                                <pre>There is a plac
e where the sid
ewalk ends

And before the 
street begins,

And there the g
rass grows soft
 and white,

And there the s
un burns crimso
n bright,

And there the m
oon-bird rests 
from his flight


To cool in the 
peppermint wind</pre></div>

                            </li> 
                            <br/>
                            <li> xfs-interface provides the <a href="./support_tools-files/xfs-interface.html#export" target="_blank">export</a> command  to export files from the XSM machine to the UNIX machine in a single step. Export the file <tt>sample.dat</tt> to the UNIX file <tt>$HOME/myexpos/data.txt</tt> using <i>xfs-inteface</i> as shown below and verify that the contents are same as that in step 8.
                              <br><br>
                              <div>
                                <pre># export sample.dat $HOME/myexpos/data.txt</pre>
                              </div>
                            </li>
                          </ol>

                          
                          <!--=========== BEGIN contents SECTION ================-->
                          <div class="container col-md-12">
                          <div class="section_area">
                          <ul class="list-group">
                           <li class="list-group-item">
                            <a data-toggle="collapse"  href="#collapseq1"><b>Q1.</b> When a file is created entries are made in the Inode table as well as the Root file. What is the need for this duplication?</a>
                            <div id="collapseq1" class="panel-collapse collapse">
                                          Inode table is a data structure which is accessible only in Kernel mode, whereas Root file is accessible both in Kernel and User mode. This enables the user to search for a file from an application program itself by reading the Root file.                                             
                                     
                            </div>
                          </li>
                          </ul>
                          </div>
                          </div>

                          <p><b style="color:#26A65B">Assignment 1 : </b> Copy the contents of Root File (from Block 5 of XFS disk) to a UNIX file <tt>$HOME/myexpos/root_file.txt</tt> and verify that an entry for <tt>sample.dat</tt> is made in it also.</p>
                          <p><b style="color:#26A65B">Assignment 2 : </b> Delete the <tt>sample.dat</tt> from the XSM machine using xfs-interface and note the changes for the entries for this file in <i>inode table, root file and disk free list</i> .</p>
                          <p><b style="color:#26A65B">Assignment 3 : </b> Read and understand <a href="http://exposnitc.github.io/arch_spec-files/machine_organisation.html" target="_blank">Machine Organisation</a> .</p>    
                          <p><b style="color:#26A65B">Assignment 4 : </b> Read and understand <a href="http://exposnitc.github.io/arch_spec-files/instruction_set.html" target="_blank">XSM Instruction set</a>.</p>     
 			
            
                       </div>
                      </div>

                      <!-- Stage 3 -->

                      <div class="panel-heading" id="list_stage3">
                        <h4 class="panel-title">
                          <a data-toggle="collapse"  href="#collapse3"><span class="fa fa-check-square-o"></span>Stage 3 : Bootstrap Loader</a>
			</h4>
			</div>
			<div id="collapse3" class="panel-collapse collapse">
                        <div class="panel-body">
                                                  <!-- Begin Learning Objectives-->
                          <div class="container col-md-12">
                          <div class="section_area">
                          <ul class="list-group">
                           <li class="list-group-item" style="background:#dff0d8">
                            <span class="fa fa-book"></span> &nbsp; <a data-toggle="collapse"  href="#lo3">Learning Objectives</a>
                            <div id="lo3" class="panel-collapse expand">
                            <ul>
                              <li><span class="fa fa-hand-o-right"></span>&nbsp;&nbsp; Use the XSM Instruction set to write a small <i>OS startup</i> code.</li>
                              <li><span class="fa fa-hand-o-right"></span>&nbsp;&nbsp; Load your <i>OS startup code</i> into the <i>boot block</i> of the disk and get this code executed on bootstrap.</li>
                            </ul>                                  
                                     
                            </div>
                          </li>
                          </ul>
                          </div>
                          </div>
                          <!-- End Learning Objectives-->

			    <p>
                            When the XSM machine is started up, the <a href="arch_spec-files/machine_organisation.html#Boot ROM" target="_blank"> ROM Code</a>, which resides in page 0 of the memory, is executed. It is hard-coded into the machine. That is, the ROM code at physical address 0 (to 511) is "already there" when machine starts up. The ROM code is called the "Boot ROM" in OS literature. Boot ROM code does the following operations :
                            <ol style="list-style-type:decimal;margin-left:10vw">
                              <li>Loads block 0 of the disk to page 1 of the memory (physical address 512).</li>
                              <li>After loading the block to memory, it sets the value of the register <a href ="http://exposnitc.github.io/arch_spec-files/machine_organisation.html" target="_blank">IP</a> (Instruction Pointer) to 512 so that the next instruction is fetched from location 512 (page 1 in memory starts from location 512).</li>
                            </ol>
                          </p> 
                          <p>In this stage, you will write a small assembly program to print "HELLO_WORLD" using XSM Instruction set and load it into block 0 of the disk using XFS-Interface as the <b>OS Startup Code</b>. As described above, this OS Startup Code is loaded from disk block 0 to memory page 1 by the ROM Code on machine startup and is then executed. </p>
			
			<i>The steps to do this are explained in detail below. </i>
                          <br/><br/>
                                
                          <ol style="list-style-type:decimal;margin-left:2px">
                            <li>
                              Create the assembly program to print "HELLO_WORLD". <br>The assembly code to print "HELLO_WORLD" :
                              <br><br>
                              <div> 
                                <pre>
MOV R0, "HELLO_WORLD"
MOV R16, R0
PORT P1, R16
OUT
HALT </pre>
			Save this file as <tt>$HOME/myexpos/spl/spl_progs/helloworld.xsm</tt>.
                              </div>  
                          </li>
                            
                            <br>
                            <li>
                            Load the file as OS Startup code to <tt>disk.xfs</tt> using XFS-Interface. Invoke the XFS interface and use the following command to load the OS Startup Code
                              <br><br>
                              <div>
                          <pre>cd $HOME/myexpos/xfs-interface
./xfs-interface
# load --os $HOME/myexpos/spl/spl_progs/helloworld.xsm
# exit

</pre>
                          </div>
                          <i> Note that the <tt>--os</tt> option loads the file to Block 0 of the XFS disk. </i>
			      </li>
                            <br/>
                            <li> Run the machine 
                              <br><br>
                              <div>
                                <pre>cd $HOME/myexpos/xsm
./xsm</pre>
                              </div>
                            </li>
                          </ol>
			  <br>
			  The machine will halt after printing "HELLO_WORLD".
			  <br><br>
			  <div>
			  <pre>
HELLO_WORLD
Machine is halting.</pre>
			  </div>
			  
			  <!--=========== BEGIN contents SECTION ================-->
                          <div class="container col-md-12">
                          <div class="section_area">
                          <ul class="list-group">
                           <li class="list-group-item">
                            <a data-toggle="collapse"  href="#collapseq2"><b>Q1.</b> If the OS Startup Code is loaded to some other page other than Page 1, will XSM work fine?</a>
                            <div id="collapseq2" class="panel-collapse collapse"> No. This is because after the execution of the ROM Code, IP points to <b>512</b> which is the 1<sup>st</sup> instruction of Page 1. So if the OS Startup Code is not loaded to Page 1, it results in <a href="./arch_spec-files/interrupts_exception_handling.html" target="_blank">exception</a> and leads to system crash.</div>

                          </li>
                          </ul>
                          </div>
                          </div>
			  <p><b style="color:#26A65B">Assignment 1 : </b>Write an assembly program to print numbers from 1 to 20 and run it as the OS Startup code.</p>
                          <p><b style="color:#26A65B">Assignment 2 : </b> Read and understand <a href="support_tools-files/spl.html" target="_blank">SPL specification</a>.</p>
			<p><b style="color:#26A65B">Assignment 3 : </b> Read and understand the tutorial on <a href="Tutorials/xsm-instruction-cycle.html" target="_blank">XSM Instruction Execution Cycle</a>.</p>
                          </div>
                          </div>
                          
                          
                        <!-- Stage 4 -->

                      <div class="panel-heading" id="list_stage4">
                        <h4 class="panel-title">
                          <a data-toggle="collapse"  href="#collapse4"><span class="fa fa-check-square-o"></span>Stage 4 : Learning the SPL Language</a>
                        </h4>
                      </div>

                      <div id="collapse4" class="panel-collapse collapse">
                        <div class="panel-body">
                                                  <!-- Begin Learning Objectives-->
                          <div class="container col-md-12">
                          <div class="section_area">
                          <ul class="list-group">
                           <li class="list-group-item" style="background:#dff0d8">
                            <span class="fa fa-book"></span> &nbsp; <a data-toggle="collapse"  href="#lo4">Learning Objectives</a>
                            <div id="lo4" class="panel-collapse expand">
                            <ul>
                              <li><span class="fa fa-hand-o-right"></span>&nbsp;&nbsp; Use the SPL language to write a small <i>OS startup code</i> and generate target using the SPL compiler.</li>
                 
                            </ul>                                  
                                     
                            </div>
                          </li>
                          </ul>
                          </div>
                          </div>
                          <!-- End Learning Objectives-->

                          
                          <p>In this stage you will write a program in SPL and compile it using the <a href="support_tools-files/spl.html" target="_blank">SPL</a> compiler. After compilation, the target machine code is generated.  We will then load this compiled code to block 0 of disk using the XFS Interface, and get it executed by the machine as in the previous stage.  </p>
                          
                         
                          <ol style="list-style-type:decimal;margin-left:2px">
                            <li>
                              Create the program to print odd numbers from 1 to 20 using SPL. (You can see more examples of SPL programs in <tt>$HOME/myexpos/spl/samples</tt>.) <br/> <br/> Here is the SPL Code to print odd numbers from 1 to 20 :
                              <br><br>
                              <div> 
                                <pre>
alias counter R0;
counter = 0;
while(counter <= 20) do
  if(counter%2 != 0) then
    print counter;
  endif;
  counter = counter + 1;
endwhile; </pre>
                              </div> 
                              SPL doesn't support variables. Instead you can directly use XSM registers for storing program data. For convenience, you can <a href="support_tools-files/spl.html" target="_blank">alias</a> the registers with appropriate identifiers to imitate the behaviour of variables. In the above program register R0 is aliased to the identifier <var>counter</var>.
                            </li>
                            
                            <br>
                            <li>Save this file as <tt>$HOME/myexpos/spl/spl_progs/oddnos.spl</tt>. Compile this SPL program using the commands
                              <br><br>
                              <div>
                                <pre>cd $HOME/myexpos/spl
./spl $HOME/myexpos/spl/spl_progs/oddnos.spl</pre>
                            </li> 

                            <br/>
                            <li> 
                              Load the file generated by the SPL compiler (<tt>$HOME/myexpos/spl/spl_progs/os_startup.xsm</tt>) as the OS startup code to <tt>disk.xfs</tt> using the XFS Interface.
                              <br>
                             
                            </li>


                            <br/>
                            <li> Run the machine. 
                             
                            </li>
                          </ol>
                          
                          The machine will halt after printing all odd numbers from 1 to 20.
                          <br><br>
                          <div>
                            <pre>
1
3
5
7
9
11
13
15
17
19
Machine is halting</pre></div>

                          
                          <p><b style="color:#26A65B">Assignment 1 : </b> Write the spl program to print sum of squares of the first 20 natural numbers. Load it 						using xfs interface and run the in the machine.</p>
                          <p><b style="color:#26A65B">Assignment 2 : </b> Read and understand
                           the <a href="support_tools-files/xsm-simulator.html" target="_blank">Debugger Specification</a>.</p>

                        </div>
                      </div>

         <!-- Stage 5 -->

                      <div class="panel-heading" id="list_stage5">
                        <h4 class="panel-title">
                          <a data-toggle="collapse"  href="#collapse5"><span class="fa fa-check-square-o"></span>Stage 5 : XSM Debugging </a>
                        </h4>
                      </div>

                      <div id="collapse5" class="panel-collapse collapse">
                        <div class="panel-body">
                            <!-- Begin Learning Objectives-->
                          <div class="container col-md-12">
                          <div class="section_area">
                          <ul class="list-group">
                           <li class="list-group-item" style="background:#dff0d8">
                            <span class="fa fa-book"></span> &nbsp; <a data-toggle="collapse"  href="#lo5">Learning Objectives</a>
                            <div id="lo5" class="panel-collapse expand">
                            <ul>
                              <li><span class="fa fa-hand-o-right"></span>&nbsp;&nbsp; Getting familiarised with the XSM Debugger.</li>
                            </ul>                                  
                                     
                            </div>
                          </li>
                          </ul>
                        </div>
                      </div>
		<!-- End Learning Objectives-->
 
 
 	  <p>In this stage you will write an SPL program with a <b> breakpoint </b> statement. The breakpoint statement translates to the <a href="arch_spec-files/instruction_set.html" target="_blank">BRKP</a> machine instruction and is used for debugging.
 	 
	If the XSM machine is run in the <a herf="support_tools-files/xsm-simulator.html" target="_blank" >Debug mode </a>, 
	on encountering the BRKP instruction, the machine simulator will suspend the program execution and allow you to inspect 
	the values of the registers, memory, os data structures etc.  Execution resumes only after you instruct the simulator to proceed.  

 	   </p>

	 <ol style="list-style-type:decimal;margin-left:2px">
		<li> Write an SPL code to generate odd numbers from 1 to 10. Add a debug instruction in between :  
		<div> 
                                <pre>
alias counter R0;
counter = 0;
while(counter <= 10) do
  if(counter%2 != 0) then
    <b>breakpoint;</b>
  endif;
  counter = counter + 1;
endwhile; </pre>
                              </div> 
		</li>
		<br>
		<li>
		Compile the program using the SPL compiler.
		</li>
		<br>
		<li> 
		Load the compiled xsm code as OS startup code into the XSM disk using the XFS interface.
		</li>
		<br>
		<li> 
		Run the machine in debug mode.
		<pre>cd $HOME/myexpos/xsm
./xsm --debug</pre>
		</li>
		<li>
		The Machine pauses after the execution of the first BRKP instruction.<br> <br>
		
		View the contents of registers using the command 
		<pre>reg</pre>
		
		Enter the following command
		<pre>mem 1</pre>
		
		This will write the contents of memory page 1 to the file mem inside the xsm folder.
		Open this file and view the contents.
		<br> <br>
		
		Use the following command step to the next instruction.
		<pre>s</pre>
		
		
		</li>
		
		<li>
		Press c to continue execution till the BRKP instruction is executed again.
		You can see that the content of R0 register changes during each iteration.
		<pre>c</pre>
		
		</li>

	</ol>
	
                          <p><b style="color:#26A65B">Assignment 1 : </b> Read and understand the <a href="virtual_machine_spec.html" target="_blank">Virtual Machine Model</a>.</p>
                          <p><b style="color:#26A65B">Assignment 2 : </b> Read and understand the <a href="arch_spec-files/paging_hardware.html" target="_blank">Address Translation Mechanism</a>.</p>
			  <p><b style="color:#26A65B">Assignment 3 : </b> Read and understand the tutorial on<a href="arch_spec-files/paging_hardware.html" target="_blank"> XSM Unprivileged Mode Execution.</a>.</p>

                    </div>
                  </div>

 		
 		<!-- Stage 6 -->

                      <div class="panel-heading" id="list_stage6">
                        <h4 class="panel-title">
                          <a data-toggle="collapse"  href="#collapse6"><span class="fa fa-check-square-o"></span>Stage 6 : Running a user program </a>
                        </h4>
                      </div>

                      <div id="collapse6" class="panel-collapse collapse">
                        <div class="panel-body">
                            <!-- Begin Learning Objectives-->
                          <div class="container col-md-12">
                          <div class="section_area">
                          <ul class="list-group">
                           <li class="list-group-item" style="background:#dff0d8">
                            <span class="fa fa-book"></span> &nbsp; <a data-toggle="collapse"  href="#lo4">Learning Objectives</a>
                            <div id="lo4" class="panel-collapse expand">
                            <ul>
                              <li><span class="fa fa-hand-o-right"></span>&nbsp;&nbsp; Learn how to set up the address space for an application. </li>

                              <li><span class="fa fa-hand-o-right"></span>&nbsp;&nbsp;Run an init program in user mode from the OS startup code.</li>
                            </ul>                     
                                     
                            </div>
                          </li>
                          </ul>
                        </div>
                      </div>
		<!-- End Learning Objectives-->

<b> Before proceeding further, it is absolutely neccesary to completely understand the tutorial on <a href="" target="_blank">  XSM Unprivileged Mode Execution</a>.</p> </b>

		<p>  In the previous stages, you wrote and executed system programs in privileged (kernel) mode. In this stage, you will write a user program in assembly code and execute it in unprivileged (user) mode.
		</p>
		
    <p> The first user program which is executed is called the INIT program. The eXpOS design stipulates that the INIT program must be stored in blocks 7 and 8 of the XSM disk. See <a href="os_implementation.html" target="_blank">Disk Organisation</a>.

    In this stage, first you will write a user program in assembly language and load it into the disk as the INIT program using XFS-Interface.

    You will then write the OS startup code such that it loads the INIT program into the memory and initiate its execution at the time of system startup.

    <br> <br>
		
    <b> User Program  </b> <br> 
		
   
	<ol style="list-style-type:decimal;margin-left:2px">
		<li>The following code illustrates the INIT program used in this stage. It computes squares of first 5 numbers. 
		The value of Register R1 during each iteration will hold the result.<br> <br>

		<pre>

//Program to calculate Squares of first 5 numbers

// R0 will hold value of n
// R1 will hold value of n^2

//Initialising R0(n) to 1
MOV R0, 1

_L1:

// Exit loop if n > 5
MOV R2, 5
GT R2, R0
JZ R2, _L2

// Computing n^2 in R1
MOV R1, R0
MUL R1, R0

//breakpoint instruction (to view contents of R1)
BRKP

// n = n + 1
ADD R0, 1

JMP _L1

_L2:

EXIT

// End of Program.
		</pre>

<!--		 
Since the XFS-Interface does not recognise comments or labels, the XSM code 
(after <a href="http://silcnitc.github.io/label-translation.html">Label Translation</a>) is given below.
<br>
-->

<p> While executing in the user mode, the machine uses logical addressing scheme. The machine translates logical addresses
     to physical addresses using the <a href="arch_spec-files/paging_hardware.html" target="_blank">address translation mechanism</a>.

In this stage, we will use a simple logical memory model where the first two logical pages are alloted for code (address 0 - 1023) and the third logical page is alloted for the stack (address 1024 - 1535). The actual logical memory model used in eXpOS is different and will be explained in the later stages.

</p>

<p>
The above code contains labels that are not recognised by the XSM machine. 

Since the code section occupies first two pages according to our memory model, the code address begins from logical address 0 
. Hence, we will translate the labels accordingly.

</p>


The code is given in bold and the corresponding addresses are added for reference. In the roadmap, the path of the file is assumed to be $HOME/myexpos/expl/expl_progs/squares.xsm  


<br> <br>
		<pre>
0<b>   MOV R0, 0 </b>
2<b>   MOV R2, 5</b>
4<b>   GT R2, R0</b>
6<b>   JZ R2, 18</b>
8<b>   MOV R1, R0</b>
10<b>  MUL R1, R0</b>
12<b>  BRKP</b>
14<b>  ADD R0, 1</b>
16<b>  JMP 2</b>
18<b>  INT 10</b></pre>


<p>

	 The methods for terminal input and output of user programs have not been studied till now. 
	 (Note that IN and OUT are privileged instructions and cannot be used in user mode programs). 
	 Hence you have to use the debug mode to view the contents of register R1 to watch the ouput. 
	  <b>Interrupt handlers </b> for input and output from user programs will be discussed in later stages.  
</p>
		
		 </li>

		
		<li> Load this file to the XSM disk as the INIT program using XFS interface.
		<pre># load --init $HOME/myexpos/expl/expl_progs/squares.xsm</pre>
The xfs-interface will store squares.xsm program to disk blocks 7-8. <br>
	
</li>  
		</ol> <br>
		
<b> INT 10</b>  <br> 

<p>
At the end of the program, a user program calls the exit system call to return control back to the operating system.
This is acheived by an INT 10 instruction. INT 10 instruction will invoke the software interrupt handler 10. This interrupt handler is responsible for graceful termination of the user program. 

Interrupt handlers and system calls will be covered in detail in later stages
of the roadmap.

Since we have only one user process for now, we will write the interrupt 10 handler with only the "halt" statement.

</p>

<ol>
	
<li>
	Create a file haltprog.spl with a single halt statement. 
	<pre>halt;</pre></li>

<li>Compile the program</li>

<li>Load the compiled code as INT 10

<pre>load --int=10 ../spl/progs/haltprog.xsm</pre>

</li>

</ol>
	<br>
<b> OS Startup Code </b> <br> 
    <p> The OS startup code will load the init process and set the OS data structures necessary
      to run the program. Finally, it transfers control to the init program using the IRET instruction. 
     </p>
     
  <ol style="list-style-type:decimal;margin-left:2px">
    <li>  Load the INIT program from the disk to the memory.
     In the memory, init program is stored in pages 65-66.
     The blocks 7-8 from disk is to be loaded to the memory pages 65-66 by the OS startup Code. 
     (See <a href="os_implementation.html" target="_blank"> Memory Organization and Disk Organization </a> ). <br> <br>
     
     <pre>loadi(65,7);
loadi(66,8);</pre>


 Load the INT10 module from the disk to the memory.
<pre>loadi(22,35);
loadi(23,36);</pre>

Load the exception handler routine from the disk to the memory.
<pre>loadi(2, 15);
loadi(3, 16);</pre>

<p>  Note the use of the  loadi instruction for loading a disk block to a memory page.
The loadi instruction will suspend the execution of the XSM machine till the disk to memory transfer is completed.  XSM will execute the next instruction after the transfer is complete.  (In later stages you will use the load instruction that can help to speed up execution). </p>


      </li>
  
     
     <li>
    <a href ="os_design-files/process_table.html#per_page_table" target="_blank"> Page Table </a> for INIT must be
    set up for address translation scheme to work correctly. 
     This is because INIT is a user process and all addresses generated are logical.
     Machine translates these logical addresses to physical addresses by looking up the page table for INIT. <br>
     <br>  
     The PTBR or Page Table Base Register stores the starting address of the page table of a process. 
     We must set PTBR to the starting address of the page table of INIT.  
<br><br>
    You need two pages for storing the INIT program code (loaded from disk blocks 7 and 8) 
    and one additional page for stack (why?). Hence, PTLR is set to value 3.  
<br>
    <pre> PTBR = PAGE_TABLE_BASE;
 PTLR = 3;</pre>
    <li>
      In the page table of INIT, set page numbers 65 and 66 for code and 76 for stack.   
      (Pages 67 - 75 are reserved. See <a href ="os_implementation.html" target="_blank"> Memory Organisation </a>.) 
      Thus, the first word of each entry must be set to the corresponding physical page number (65 ,66 and 76).
      Set the second word (<a href ="arch_spec-files/paging_hardware.html#aux_info" target="_blank"> Auxiliary information </a>) for pages 65 and 66 to "0100" and page 76 to "0110".  This sets the 
      code pages "read only" and stack "read/write".  (why?)  
      <br>
      
      <pre>[PTBR+0] = 65;
[PTBR+1] = "0100";
[PTBR+2] = 66;
[PTBR+3] = "0100";
[PTBR+4] = 76;
[PTBR+5] = "0110";</pre>
    </li> 
    
    <i> Note: Here we have introduced a simple memory model with 2 page code and 1 page stack memory. <br>
    The actual memory model which you will be using is different and will be explained in the later stages. . </i>
     
    <br> <br>
    

    <li>
    The OS Startup Code transfers control of execution to the user program using an IRET instruction. An IRET performs the following operations
    <br>
      <ol style="list-style-type:lower-roman;margin-left:20px">
    
      <li>The privilege mode is changed from KERNEL to USER mode. </li>
    
      <li>The instruction pointer is set to the value at the top of the user stack <br> </li>

      <li> The value of SP is decremented by 1 </li>
  
      </ol>
<p>
    The code of this program must execute from logical address 0.  
    Hence IP or the instruction pointer needs to be set to 0 before the user program starts execution. 
    As IP cannot be set explicitly, put the value of starting IP 0 at the top of the stack, and IRET instruction will implicitly 
    set the IP to this value. Since the OS Startup Code runs in KERNEL mode, the physical address of SP must be used 
    to access the top of the stack. Stack of INIT process is allocated at physical page number 76.
    Its corresponding physical address is 76 * 512. The stack pointer must be set to point to this address so that IRET fetches the correct address.

</p>
    
    <pre>[76*512] = 0;
SP = 2*512;</pre>
    </li> <br>

    
    <li> Use the <i>ireturn</i> instruction to transfer control to user program. <i>ireturn</i> translates to IRET machine instruction
    <br> <br>
    <pre>ireturn; </pre>
     
    
    </li> 
    
    
    </ol>
    <br>

<b> Exception handler</b> <br> 

<p>
We also load the exception handler routine to memory.  The machine may raise an exception if it encounters any unexpected events like illegal instruction, invalid address, page table entry for a logical page not set valid etc.  Our default action is to halt machine execution in the case of an exception.  In later stages you will learn to handle exceptions in a more elaborate way. 
</p>

<p> Load the haltprog.xsm used above as the exception handler using XFS-interface </p>
<pre>load --exhandler ../spl/progs/haltprog.xsm</pre>

<br> <br> 		
		<b> Making Things Work</b> <br> <br>
	<ol style="list-style-type:decimal;margin-left:2px">
		<li> Save the OS startup Code as $HOME/myexpos/spl/spl_progs/os_startup.spl. Compile this file using SPL compiler.		<pre> cd $HOME/myxos/spl
./spl $HOME/myxos/spl/spl_progs/os_startup.spl</pre>		
		</li>
		<li>
		This will generate a file $HOME/myexpos/spl/spl_progs/os_startup.xsm.	
		Load this file as the OS startup code to disk.xfs using the XFS Interface.
		Invoke the XFS interface and use the following command to load the OS Startup Code.
		<pre># load --os $HOME/myxos/spl/spl_progs/os_startup.xsm
# exit</pre>
		</li>
		
		<li>Run the machine in debug mode. (We will disable the timer for now).  
		<pre>cd $HOME/myxos/xsm/
./xsm --debug --timer 0</pre>
		</li>
				
		<li>
			View the contents of R1 at each step.
		</li>
		
<br>

<p>
<b>Exercise </b> : Change virtual memory model such that code occupies logical pages 4 and 5 and the stack lies in logical page 8.
You will have to modify the user program as well as the os startup code.	
  </p>	
    <br>

	</ol>
		

		<!--========= Stage descrptions ends here ===========-->
                </div>
            </div>
            
            
             <!-- Stage 7 -->

                      <div class="panel-heading" id="list_stage7">
                        <h4 class="panel-title">
                          <a data-toggle="collapse"  href="#collapse7"><span class="fa fa-check-square-o">
                          </span>Stage 7 : ABI and XEXE Format
                        </h4>
                      </div>

                      <div id="collapse7" class="panel-collapse collapse">
                        <div class="panel-body">
                            <!-- Begin Learning Objectives-->
                          <div class="container col-md-12">
                          <div class="section_area">
                          <ul class="list-group">
                           <li class="list-group-item" style="background:#dff0d8">
                            <span class="fa fa-book"></span> &nbsp; <a data-toggle="collapse"  href="#lo7">Learning Objectives</a>
                            <div id="lo7" class="panel-collapse expand">
                            <ul>
                              <li><span class="fa fa-hand-o-right"></span>&nbsp;&nbsp; Familiarise with the Application Binary Interface(ABI) of eXpOS.</li>
                <li><span class="fa fa-hand-o-right"></span>&nbsp;&nbsp; Modify the INIT program to comply with the eXpOS ABI.</li>
                            </ul>                                  
                                     
                            </div>
                          </li>
                          </ul>
                        </div>
                      </div>
    <!-- End Learning Objectives-->

        
        
        <br>
        In this stage we will rewrite the user program and OS startup code of Stage 6 in compliance with expos ABI. 
        <br><br>
        Read and Understand the eXpOS <b> Virtual Address Space Model </b> 
        and  <b> XEXE Executable File Format </b> from <a href="abi.html#xexe" target="_blank"> eXpOS ABI Documentation </a> before proceeding further.
        <br><br>
        <b>Modifying INIT</b>
        
        <p>The INIT program must be modified to comply with the XEXE executable format. 
        The executable format stipulates that the first 8 words of the file must contain a header.
        The rest of the file contains the program instructions.  The OS is expected to load the file
        into logical pages starting from page 4.  Thus the first disk block of the program is loaded 
        into logical address starting from 2048,
        second (if the file size exceeds 512 words) to logical addresses starting from 2560 
        and so forth. </p>
        
        <p>
        Since the first instruction starts after the 8 word header, the first instruction in the
        program will be loaded into memory address 2056. Since each instruction requires two words,
        the second instruction will start at memory address 2058 and so on.  Thus the jump addresses
        in the INIT program must be designed with this in mind.  
</p>
    <p>    The INIT program complying to ABI is given below. The code is given in bold and the corresponding addresses are added for reference.   
      
        </p>
         
        <pre>
2048<b>  0</b>
2049<b>  2056</b>
2050<b>  0</b>
2051<b>  0</b>
2052<b>  0</b>
2053<b>  0</b>
2054<b>  0</b>
2055<b>  0</b>         
2056<b>  MOV R0, 0</b>
2058<b>  MOV R2, 5</b>
2060<b>  GT R2, R0</b>
2062<b>  JZ R2, 2076</b>
2064<b>  MOV R1, R0</b>
2066<b>  MUL R1, R0</b>
2068<b>  BRKP</b>
2072<b>  ADD R0, 1</b>
2074<b>  JMP 2060</b>
2076<b>  INT 10</b></pre>
  <br>      
            <b>Modifications to OS Startup Code</b><br>
            <ol style="list-style-type:decimal;margin-left:2px">
        <li> Load Library Code from disk to memory</li>
        
        eXpOS has a shared library which is loaded into pages 63 and 64 of the memory.  The ABI sipulates that the OS must load the library to logical page 0 and 1 of every user program.  The purpose of the library is to provide some standard code for handling dynamic memory allocation as   



        <pre>
loadi(63,13);
loadi(64,14);</pre>
        <li> Modify the Page table entries according to ABI. 
        
As noted, the first disk block of the INIT program (block 7) must be loaded to logical page 4.
Similarly, block 8 must be loaded to logical page 5.  
The ABI stipulates that two pages must be allocated for the stack at logical pages 8 and 19. 

<br><br>

The following code sets page table entries for logical page 4 (of the code) and logical page
8 (stack).  Note that the code page must be kept read only whereas stack must be read-write.
(see page table settings for details).     

        <!-- Remove if too spoonfeeding -->
        <pre>
//Library
[PTBR+0] = 63;
[PTBR+1] = "0100";
[PTBR+2] = 64;
[PTBR+3] = "0100";

//Heap
[PTBR+4] = -1;
[PTBR+5] = "0000";
[PTBR+6] = -1;
[PTBR+7] = "0000";

//Code
[PTBR+8] = 65;
[PTBR+9] = "0100";
[PTBR+10] = 66;
[PTBR+11] = "0100";
[PTBR+12] = -1;
[PTBR+13] = "0000";
[PTBR+14] = -1;
[PTBR+15] = "0000";

//Stack
[PTBR+16] = 76;
[PTBR+17] = "0110";
[PTBR+18] = 77;
[PTBR+19] = "0110";         
</pre>
        </li>
<li>
Since the total address space of a process is 10 pages, PTLR regiser must be set to value 10. 
<pre>PTLR = 10;</pre>
</li>

<li>
  Initialise IP to the second word in the header. Since the first code page is loaded into memory page 65, 
  the address of the second word in header is calculated as (65 * 512) + 1. This value is stored to the top of the user stack. 
  The machine on executing IRET instructions pops this value from the stack and sets IP to that value. 

  <pre>
SP = 8*512; 

[76*512] = [65 * 512 + 1];  
</pre>
</li>
      </ol>
            
  
  <br>
  <b>Making Things Work </b><br><br>
            <ol style="list-style-type:decimal;margin-left:2px">
        <li>
          Compile and load the modified OS startup Code
        </li>
        
        <li>
          Load the modified user program
        </li>
        
        <li>
          Run the machine in debug mode.
        </li>
      </ol> 
            
        <!--========= Stage descrptions ends here ===========-->
                </div>
            </div>
                
            
            <!-- Stage 8 -->

                      <div class="panel-heading" id="list_stage8">
                        <h4 class="panel-title">
                          <a data-toggle="collapse"  href="#collapse8"><span class="fa fa-check-square-o"></span>Stage 8 : Interrupt Service Routines</a>
                        </h4>
                      </div>

                      <div id="collapse8" class="panel-collapse collapse">
                        <div class="panel-body">
                            <!-- Begin Learning Objectives-->
                          <div class="container col-md-12">
                          <div class="section_area">
                          <ul class="list-group">
                           <li class="list-group-item" style="background:#dff0d8">
                            <span class="fa fa-book"></span> &nbsp; <a data-toggle="collapse"  href="#lo8">Learning Objectives</a>
                            <div id="lo8" class="panel-collapse expand">
                            <ul>
                              <li><span class="fa fa-hand-o-right"></span>&nbsp;&nbsp; Familiarise with the hardware interrupt mechanism in eXpOS.</li>
                              <li><span class="fa fa-hand-o-right"></span>&nbsp;&nbsp; Familiarise with the kernel stack management during hardware ISRs.</li>
                            </ul>                                  
                                     
                            </div>
                          </li>
                          </ul>
                        </div>
                      </div>
		<!-- End Learning Objectives-->
 
	   <p>An interrupt is a signal to the processor to request the kernel services. An interrupt can be raised by the hardware (hardware interrupt) or from within a user program (software interrupts). 

      When an interrupt occurs , the XSM machine saves the value of IP + 2 to top of user stack, switches the execution mode from protected to real and transfers control to the corresponding Interrupt Service Routine.
  </p>

<p>
    Timer interrupt, disk controller interrupt and console interrupt are the hardware interrupts supported by XSM.
    There are 15 software interrupts which can be invoked using machine instructions <b>INT 4</b> to <b>INT 18</b> 
    from within the user programs. 

  </p>
  
<p>
     Additionaly, the XSM machine raises an exception for errors or events occurring during program execution that cannot be handled within the program itself (for eg Illegal Instruction or Page fault). The exception handler is invoked for such cases.

     </p>

    
 	  <p> 
    Interrupts can only be triggered or invoked in user mode. In Kernel mode interrupts are disabled.
    Interrupt Service Routines are stored in fixed memory locations and occupies 2 pages in the memory.

    
 	   </p>
 	    	  
 	  <p>In this stage, you will write a sample interrupt handler for the timer interrupt which prints the message "TIMER" on occurance of every timer interrupt and returns control to the user program.</p>
 	  
    <p><b>Read and understand the <a href="os_design-files/stack_interrupt.html" target="_blank"> Kernel Stack Management during Interrupts </a> before proceeding further.</b></p>

 	<br>
 	<b style="font-size:20px">Modifications to OS Startup Code </b>
 	
	<p>OS Startupt code used in the previous stage has to be modified to incorporate interrupts.</p>
	<ol style="list-style-type:decimal;margin-left:2px">
	<li>Load the timer interrupt routine from disk blocks 17 and 18 to memory pages 4 and 5.
	<div>
	<pre>load(4, 17);
load(5, 18);</pre>
	</div>
	</li>	
	<br>
	
	<li>  
Set the User Area page number in the <a href="os_design-files/process_table.html">Process Table</a> entry
 of the current process. User Area page is allocated in the physical page number 80.
	<pre>
[PROCESS_TABLE + 11] = 80;</pre>
	</li>
	<li>
	Set the current PID field in the <a href="os_design-files/mem_ds.html#ss_table">System Status Table</a>.
	<div>
	<pre>
[SYSTEM_STATUS_TABLE + 1] = 0;</pre></div>
	</li>
	</ol>
	<br>
 	<b style="font-size:20px">Timer Interrupt</b>
 	
 	<p> The XSM simulator has a timer which invokes the timer 
 	interrupt routine after a specific number of instructions. 
 	(Note that, in real machines, a timer interrupt is triggered in fixed intervals of time using a timer device).</p>
 	

<p><b>NOTE:</b> Timer Interrupt is triggered at fixed intervals of instructions. 
The interval can be specified when the XSM simulator is started 
(see <a href="support_tools-files/xsm-simulator.html"> XSM</a>). 
Default interval for timer interrupt is 10 instructions.</p>

<p> Your task is to display "TIMER" every time a timer interrupt is triggered. 
 	You will create a timer interrupt routine, which prints "TIMER". 

  Detailed instructions to get this done are given below.</p>
	 <ol style="list-style-type:decimal;margin-left:2px">
		 
		 
		<li> 
		Save the current value of User SP into the corresponding Process Table entry.
    Obtain the process id of the currently running process from <a>System Status Table</a>.
		This value can be used to get its <a>Process Table</a> entry.
		
		<b>NOTE: </b>Do not use registers to store intermediate results at this point as the user context is not saved yet. 
		<div> 

 <pre>
[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 13] = SP;
</pre> </div> </li>

<li> Set the SP to beginning of the kernel stack.

<div>
	
<pre>
// Setting SP to UArea Page number * 512 - 1
SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 11] * 512 - 1;
</pre> </div> </li>

<li> Save the user context to the kernel stack using the <a>Backup</a> instruction.

<div>
	
<pre>
backup;
</pre> </div> </li>

<li> Print "timer".

<div>
	
<pre>
print "TIMER";
</pre> </div> </li>

<li> Restore the user context from the kernel stack and set SP to the user SP saved in Process Table before returning 
to user mode.

<div>
	
<pre>
restore;
SP = [PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 13];
</pre> </div> </li>

<li> Use ireturn statement to switch to user mode.
<div>
	
<pre>
ireturn;
</pre>
                              </div> 
		</li>
		<br>
		<li>
		Save this file in your UNIX machine as $HOME/myexpos/spl/spl_progs/sample_timer.spl
		</li>
		<br>
		<li> 
		Compile this program using the SPL compiler.
		</li>
		<br>
		<li> 
		Load the compiled XSM code as the timer interrupt into the XSM disk using XFS Interface.
		<div>
		<pre>cd $HOME/myexpos/xfs-interface
./xfs-interface
# load --int=timer $HOME/spl/spl_progs/sample_timer.xsm
# exit</pre>
		</div>
		</li>
		
	</ol>
 	
    </div>
    </div>              
                   <!-- Stage 9 -->

                      <div class="panel-heading" id="list_stage9">
                        <h4 class="panel-title">
                          <a data-toggle="collapse"  href="#collapse9"><span class="fa fa-check-square-o"></span>Stage 9 : Introduction to software interrupts </a>
                        </h4>
                      </div>

                      <div id="collapse9" class="panel-collapse collapse">
                        <div class="panel-body">
                            <!-- Begin Learning Objectives-->
                          <div class="container col-md-12">
                          <div class="section_area">
                          <ul class="list-group">
                           <li class="list-group-item" style="background:#dff0d8">
                            <span class="fa fa-book"></span> &nbsp; <a data-toggle="collapse"  href="#lo9">Learning Objectives</a>
                            <div id="lo9" class="panel-collapse expand">
                            <ul>
                              <li><span class="fa fa-hand-o-right"></span>&nbsp;&nbsp; Familiarise with the timer interrupt mechanism in eXpOS.</li>
                              <li><span class="fa fa-hand-o-right"></span>&nbsp;&nbsp; Familiarise with the XEXE format.</li>
                            </ul>                                  
                                     
                            </div>
                          </li>
                          </ul>
                        </div>
                      </div>
		<!-- End Learning Objectives-->
		<p>

 	In the Stage 7, we wrote a user program and used the BRKP instruction to view the result in debug mode.

 	In this stage, we will modify the program such that the result is printed directly to the terminal. 
	The terminal print is acheived by issuing a a write system call from the user program. 
 	The ISR corresponding to it is INT 7. We will also write the INT7 ISR.

 	  
</p>

  


 	<p><b>Read and understand the <a href="os_design-files/stack_smcall.html" target="_blank"> Kernel Stack Management during system calls </a> before proceeding further.</b></p>
 	
<b style="font-size:18px">Modifying the user program</b>
<br> <br>
<p>The user program is modified such that a write system call is issued to print the contents of register R1 to the terminal. The BRKP instruction for the user program in Stage 7 is replaced by instructions for the following:
</p>

<ol style="list-style-type:decimal;margin-left:2px">

<li>Save the registers in use to the user stack. As per specification, since the user program has control over transfer to the system call routine , the OS expects that it saves its own context before issuing the system call.  
</li>

<br>

<li> Push the system call number and arguments to the stack. For the Write system call,  the sytem call number is 5. Argument 1 is the file descritor which is -2 for the terminal. Argument 2 is the word to be written which is present in R1. By convention, all system calls have 3 arguments. As we do not have a third argument in this case, push any register, say R0 on to the stack. 
</li> <br>

<li> Push any register, say R0 to allocate space for the return value. </li> <br>

<li>Invoke the interrupt by "INT7" instruction. </li> <br>

<li> Pop out all the system call number and arguments which were pushed on the stack prior to the system call. </li>
<br>
<li> Restore the register context from the stack. </li>
<br>
</ol>
	<p>The resulting program is given below. 
	<div>
	<pre>
0
2056
0
0
0
0
0
0					
MOV R0, 0
MOV R1, 0
MOV R2, 20
GE R2, R0
JZ R2, 2076
MOV R1, R0
MUL R1, R0


PUSH R0
PUSH R1
PUSH R2

MOV R0, 5
MOV R2, -2

PUSH R0	
PUSH R2
PUSH R1
PUSH R0
PUSH R0

INT 7

POP R1
POP R1
POP R1
POP R1
POP R1

POP R2
POP R1
POP R0

ADD R0, 1
JMP 2060

INT 10
	</pre>
	</div>
	</p>
	<br>
	
	<br>
	<b style="font-size:20px">INT 7</b>
	<p>The write operation is handled by Interrupt 7.
	The word to be printed is passed from the user program through its user stack as the 
	second argument to the interrupt routine. The interrupt routine retrieves this word from the stack
	and writes it to the terminal using the OUT instruction. </p>
	<p>Detailed instructions for doing so are given below:</p>
	<ol style="list-style-type:decimal;margin-left:2px">
	<li> Store the value of user SP in a register as we need it for further computations.
	<div><pre>alias userSP R0;
userSP = SP;</pre>
	</div>
	</li>
	<br>
	<li>Switch the stack from user stack to kernel stack. 
<ol style="margin-left:20px;list-style-type:circle;">
	<li>Save the value of SP in the user SP field of Process Table entry of the process.</li>
	<li>Set the value of SP to beginning of the kernel stack.</li>
</ol>
	</li>
	<br>
	<li>In user mode, logical addresses are translated to physical address by the machine using its
	 <a href="arch_spec-files/paging_hardware.html" target="_blank">address translation scheme</a>.
	 Since interrupts are executed in kernel mode, the actual physical address is used to access memory 
	  locations. Hence to access the word to be printed we must 
	  calculate the physical address of the memory location where the word is stored.
		According to the system call conventions, userSP - 3 is the location of the word to be printed.
	  So we will manually adress translate UserSP - 3.
	<div>
	<pre>alias physicalAddrWord R1;
physicalAddrWord = ([PTBR + 2 * (userSP - 3/ 512)] * 512) + ((userSP - 3) % 512);</pre>
	</div>
	</li>
	<br>
	<li>
	Extract the word to be printed and store it in a register.
	<div>
	<pre>alias word R2;
word = [physicalAddrWord];</pre>
	</div>
	</li>
	<br>
	<li>
	Write the word to the terminal using the print instruction. 	<div>
	<pre>print word;</pre>
	</div>
	</li>
	<br>
	<li>
	Set the return value as 0 indicating success. 
	According to system call convention, return value is stored at memory location userSP -1 in the user stack.
	<div><pre>alias physicalAddrRetVal R3;
[physicalAddrRetVal] = ([PTBR + 2 * (userSP - 1/ 512)] * 512) + ((userSP - 1) % 512);</pre></div></li>
	<br>
	<li>
	Pass control back to the user program using the ireturn statement.
	</li>
	<br>


	</ol>

	<li>
	Save this file in your UNIX machine as $HOME/myexpos/spl/spl_progs/sample_int7.spl
	</li>
	<br>
	<li> 
	Compile this program using the SPL compiler.
	</li>
	<br>
	<li> 
	Load the compiled XSM code as INT 7 into the XSM disk using XFS Interface.
	</li>
	<br>
	<li> 
	Run the Machine with timer disabled.
	</li>

 	<br>
	<!--
	<p><b style="color:#26A65B">Assignment :</b> Why should we calculate the physical address of userSP-3 and userSP -1
	seperately instead of calculating the physical address of userSP and subtracting required indices from it? </p>
	-->
 
          </div>
        </div>
        
     

     <!-- Stage 10 -->

                      <div class="panel-heading" id="list_stage10">
                        <h4 class="panel-title">
                          <a data-toggle="collapse"  href="#collapse10"><span class="fa fa-check-square-o"></span>
                          Stage 10 : MultiProgramming</a>
                        </h4>
                      </div>

                      <div id="collapse10" class="panel-collapse collapse">
                        <div class="panel-body">
                            <!-- Begin Learning Objectives-->
                          <div class="container col-md-12">
                          <div class="section_area">
                          <ul class="list-group">
                           <li class="list-group-item" style="background:#dff0d8">
                            <span class="fa fa-book"></span> &nbsp; <a data-toggle="collapse"  href="#lo10">Learning Objectives</a>
                            <div id="lo10" class="panel-collapse expand">
                            <ul>
                              <li><span class="fa fa-hand-o-right"></span>&nbsp;&nbsp; Implement round robin scheduling.</li>
      
                            </ul>                                  
                                     
                            </div>
                          </li>
                          </ul>
                        </div>
                      </div>
		<!-- End Learning Objectives-->    
        
        	<p> Multiprogramming refers to running more than one process simultaneously. In this stage, you will learn how to run two processes - one to print even numbers and one to print odd numbers - concurrently on the machine.</p> 

        	<p>In the previous stage you made the timer interrupt to display "TIMER" at fixed intervals. However, the actual function of timer interrupt routine is to preemt the current running process and to transfer execution to another ready processes. 
        	In this stage we will modify the timer ISR to implemt this functionality. 
        	</p>
        
        	 
        	 <b>Modification to Timer Interrupt Routine</b>

        	 <p> eXpOS supports module calls in kernel mode due to the availablilty of kernel stack. 
        	XSM supports 7 modules MOD_0 to MOD_7 which can be called by the CALL MOD_n instruction. 
        	We will modify the timer interrupt routine so that it calls the scheduler module. </p>
        	
        	<p>Read and Understand <a href="os_design-files/stack_description.html">Kernel Stack Managemnt during Module calls </a> before proceeeding. </p> 

        	<p>	Modify timer interrupt routine to set the state of the current process to ready 
        		and call the scheduler module (Module 5). <br> 
        		See the full algorithm <a href="os_design-files/timer.html">here</a>.
        	</p>


		<b> Scheduler Module </b>

			<p>
				See the full algorithm <a href="os_design-files/context_switch_module.html">here</a>.
			</p>    

		<b> Modification to OS Startup code </b>
		
		The OS startp code must be modified to initialise kernel data structures for both processes.

		<ol style="list-style-type:decimal;margin-left:2px">
				<li>Load the odd program as init and the even program as an executable
				<pre>
load --init < path to odd.xsm >
load --exec < path to even.xsm > </pre> 
				Dump the <a href="os_design-files/disk_ds.html#inode_table"> inodetable </a> using <i>dump --inodetable</i> command in xfs-interface. Check the adress of first data block. Load the disk block to a free page in the memory, say 


				</li>
				<li></li>

		</ol>

        </div>
        </div>

					<!-- Stage 12 -->

                      <div class="panel-heading" id="list_stage12">
                        <h4 class="panel-title">
                          <a data-toggle="collapse"  href="#collapse12"><span class="fa fa-check-square-o"></span>Stage 12 : Process system calls </a>
                        </h4>
                      </div>

                      <div id="collapse12" class="panel-collapse collapse">
                        <div class="panel-body">
                            <!-- Begin Learning Objectives-->
                          <div class="container col-md-12">
                          <div class="section_area">
                          <ul class="list-group">
                           <li class="list-group-item" style="background:#dff0d8">
                            <span class="fa fa-book"></span> &nbsp; <a data-toggle="collapse"  href="#lo9">Learning Objectives</a>
                            <div id="lo12" class="panel-collapse expand">
                            <ul>
                              <li><span class="fa fa-hand-o-right"></span>&nbsp;&nbsp; Implement the process system calls.</li>
                            </ul>                                  
                                     
                            </div>
                          </li>
                          </ul>
                        </div>
                      </div>

	<!-- End Learning Objectives-->    
        In this stage you will implement the process system calls. There are three process system calls : fork, 
        exec and exit with system call numbers 8, 9 and 10 and are handled by interrupt routines 8, 9 and 10 respectively.
          <br><br>
		<b>Modifications to OS Startup Code</b><br>
		<ol style="list-style-type:decimal;margin-left:2px">
        <li> Initialise the state of all free process table entries to TERMINATED state. This is done to
        identify the free entries while searching for a process table entry for a new process.</li>
        <li> The OS supports maintains information about free memory pages usinng the <a href ="os_design-files/mem_ds.html#mem_free_list" target="_blank">Memory Free List</a> data structure.
        The used pages are marked as 1 and the unused pages are marked as 0 in Memory Free List. The pages 0 - 75 are
        reserved for the OS and the pages 75 - 80 are used as stack pages and user area pages by init and idle programs.
        Hence, mark the pages 0 - 80 as used and 81 - 127 as unused. </li>
        <li> Load interrupts 8, 9 and 10 from disk blocks 31 - 36 to memory pages 18 - 23.</li>
        <li> Load modules 2, </li>
		</ol>
		<br><br>
		<b>Fork System Call</b>
		<p>Fork System Call replicates the process invoking the system call. The heap, code and library regions
		 of the parent are shared by the child. A new stack is allocated to the child and the parent's stack 
		 is copied into the child's stack.</p>
		<ol style="list-style-type:decimal;margin-left:2px">
		<li>Save the value of SP in the Process Table entry of the process and set the value of SP to the 
		beginning of User Area Page.
         </li>
         <li>Invoke the GetPTentry() from Process Manager module to find a free Process Table entry for the
          child process. Ensure that you push all the used registers to stack before invoking the module.</li>
         <li>If the value returned is -1 indicating no free Process Table entries, retuen -1 indicaing failure.</li>
         <li>The new process requires 3 memory pages: 2 for user stack and 1 for User Area Page.
         Invoke the Getpage() function in Memory Manager module thrice to obtain 3 memory pages.
         </li>
         <li>The index of the Process Table entry found gives the PID of the child process.
         PAGE_TABLE_BASE + PID*20 would give the PTBR of the child process.
         Copy the page table entries (code, heap and library) from the parent's page table to the 
         child. Set the page table entries of user stack as the newly found pages for user stack.</li>
         <li>The heap, code and library regions of the parent are shared by the child. 
         For each page shared, increment its value in the Memory Free List</li>
         <li>Copy the parent's <a href="process_table.html#machine_state" target="_blank">Machine State</a> 
         (except PTBR and User Area Page number). Set the PTBR field of the Machine State to the address of 
         the page table of the child. Set the User Area Page number field as the newly found page for User Area Page.</li>
		 <li>Copy the user stack of parent to the user child of child.</li>
		 <li>Set the return  value to 0 for the child process.</li>
		 <li>The PID of the child process is set as the return value for the parent process.</li>
		 <li>Set state of child process to CREATED. </li>
		 <li>Set the value of SP to point to the user stack.</li>
		 <li>Return to the parent process.</li>
		 </ol>
		 <br><br>
		 <b>GetPTentry()</b>
		 <ol style="list-style-type:decimal;margin-left:2px">
		 <li>Iterate through the Process Table entries to find a free entry to be allocated for the new process</li>
		 <li>If no free entry is found, return -1.</li>
		 </ol>
		 <br><br>
		 <b>Getpage()</b><br>
		 <ol style="list-style-type:decimal;margin-left:2px">
        <li>Iterate through the Memory Free List to find a free entry (denoted by 0).</li>
        <li>If no free entry is found,....</li>
        <li>Return the index of the free entry.</li>
        </ol>
        <br><br>
        <b>Exec System Call</b>
        <p>Exec destroys the present process and loads the executable file given as input into a new memory 
        address space. A successful Exec operation results in the extinction of the invoking process and hence
        never returns to it.However, the newly created process will inherit the PID of the calling process.</p>
        <ol style="list-style-type:decimal;margin-left:2px">
			<li>Retrieve the filename of the new process from the user stack.</li>
			<li>Return -1 if the filename is NULL.</li>
			<li>Iterate through the Inode Table to find the inode index of the file.</li>
			<li>If file is not found, return -1.</li>
			<li>Inorder to overlay the existing process with the new process passed as argument, you will first
			deallocate the resources of the existing process. Invoke the FreePTentry() and FreePageTable() from Process manager module
			with the current PID as the argument to free the Process Table and Page Table entries of the current process.</li>
			<li>Invoke the Getpage() function in Memory Manager module to obtain 4 memory pages- 2 for user stack,
			1 for User Area Page and 1 for code.</li>
          <li>Invoke DWrite() from Device manager module to load the first code page of the new process
          from disk to memory. </li>
          <li>Set up the page table entries of the new process. The first code page must be </li>
          <li>Set up the Process Table entries.</li>
          <li>Obtain the value of IP from the first code page and set this value to top of the user stack.</li>
          <li>Set the value of SP as 4096.</li>
      </div>
      
      
    </section>

<!--=========== Intoduction Section Ending ===============-->


     <!--=========== BEGIN FOOTER ================-->
     <footer id="footer">
       <div class="container">
         <div class="row">
           <div class="col-lg-6 col-md-6 col-sm-6">
             <div class="footer_left">
               <p><a href="http://www.nitc.ac.in/">National Institute of Technology, Calicut</a></p>
             </div>
           </div>
         </div>
       </div>
      </footer>
      <!--=========== END FOOTER ================-->

     <!-- Javascript Files
     ================================================== -->
  
     <!-- initialize jQuery Library -->
    <script src="js/jquery.min.js"></script>
    <!-- Google map -->
    <script src="js/map_js.js"></script>
    <script src="js/jquery.ui.map.js"></script>
     <!-- For smooth animatin  -->
    <script src="js/wow.min.js"></script> 
    <!-- Bootstrap js -->
    <script src="js/bootstrap.min.js"></script>
    <!-- superslides slider -->
    <script src="js/jquery.superslides.min.js" type="text/javascript"></script>
    <!-- slick slider -->
    <script src="js/slick.min.js"></script>    
    <!-- for circle counter -->
    <script src='js/jquery.circliful.min.js'></script>
    <!-- for portfolio filter gallery -->
    <script src="js/modernizr.custom.js"></script>
    <script src="js/classie.js"></script>
    <script src="js/elastic_grid.min.js"></script>
    <script src="js/portfolio_slider.js"></script>

    <script>
      $(document).on("click", function (event) {
            switch(event.target.id){
              case 'stage1': $('#collapse1').removeClass('collapse').addClass('expand'); break;
              case 'stage2': $('#collapse2').removeClass('collapse').addClass('expand'); break;
              case 'stage3': $('#collapse3').removeClass('collapse').addClass('expand'); break;
              case 'stage4': $('#collapse4').removeClass('collapse').addClass('expand'); break;
              case 'stage5': $('#collapse5').removeClass('collapse').addClass('expand'); break;
            }
            //window.scrollTo(0, $("#list_"+event.target.id).offset().top);
            $('html, body').animate({
                scrollTop: $("#list_"+event.target.id).offset().top-70
            });
        });
      
    </script>
    <!-- Custom js-->
    <script src="js/custom.js"></script>
  </body>
</html>
