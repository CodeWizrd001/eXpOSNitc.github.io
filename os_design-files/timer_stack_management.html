<!--This document consists of header and footer only -->

<!DOCTYPE html>
<html lang="en">
  <head>

    <!-- Basic Page Needs
    ================================================== -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

     <title>Kernel Stack Management During Context switch</title>


 <!-- Mobile Specific Metas
    ================================================== -->
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Favicon -->
    <link rel="shortcut icon" type="image/png" href="../img/favicon.jpg"/>

    <!-- CSS
    ================================================== -->       
    <!-- Bootstrap css file-->
    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <!-- Font awesome css file-->
    <link href="../css/font-awesome.min.css" rel="stylesheet">
    <!-- Superslide css file-->
    <link rel="stylesheet" href="../css/superslides.css">
    <!-- Slick slider css file -->
    <link href="../css/slick.css" rel="stylesheet"> 
    <!-- smooth animate css file -->
    <link rel="stylesheet" href="../css/animate.css">  
    <!-- Elastic grid css file -->
    <link rel="stylesheet" href="../css/elastic_grid.css"> 
    <!-- Circle counter cdn css file -->
    <link rel='stylesheet prefetch' href='../css/jquery.circliful.css'>    
    <!-- Default Theme css file -->
    <link id="orginal" href="../css/themes/eucalyptus-theme.css" rel="stylesheet">
    <!-- Main structure css file -->
    <link href="../style.css" rel="stylesheet">
   
    <!-- Google fonts -->
    <link href='../css/opensans.css' rel='stylesheet' type='text/css'>
    <link href='../css/varela.css' rel='stylesheet' type='text/css'>
    <link href='../css/montserrat.css' rel='stylesheet' type='text/css'>

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body id="stack_desc"> 
	  
     <!-- BEGAIN PRELOADER 
    <div id="preloader">
      <div id="status">&nbsp;</div>
    </div>
    <!-- END PRELOADER -->

  
    <!--=========== BEGIN HEADER SECTION ================-->
    <header id="header">
      <!-- BEGIN MENU -->
      <div class="menu_area">
        <nav class="navbar navbar-default navbar-fixed-top past-main" role="navigation"> 
          <div class="container">
          <div class="navbar-header">
            <!-- FOR MOBILE VIEW COLLAPSED BUTTON -->
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            <!-- LOGO -->

            <!-- TEXT BASED LOGO -->
            <a class="navbar-brand" href="../index.html">eXpOS<span>NITC</span></a>
            
                              
          </div>
          <div id="navbar" class="navbar-collapse collapse">
            <ul id="top-menu" class="nav navbar-nav navbar-right main_nav">
              <li><a href="../index.html">Home</a></li>
              <li><a href="../documentation.html" target="_blank">Documentation</a></li> 
              <li><a href="../Roadmap.html" target="_blank">Roadmap</a></li>
               <li><a href="../Downloads.html" target="_blank">Downloads</a></li> 
               <li><a href="../faq.html" target="_blank">FAQ</a></li>
              <li><a href="../About_us.html" target="_blank">About Us</a></li>                                    
            </ul>           
          </div>
          </div>     
        </nav>  
      </div>
      <!-- END MENU -->

      
    </header>
    <!--=========== End HEADER SECTION ================--> 

	 <!--=========== BEGIN  ================-->
	
     <div class="container">
         
         	
         <br><br><br><br>

	 <div class="heading">
         <h2 style="font-size:30px">Kernel Stack Management During Context Switch</h2>
	 <br><br>
    	 </div>
         <br>
         <p>Context switch involves switching a machine from executing one process to executing another even before the former is completed. This involves saving the state of all volatile data like registers, PTBR, BP, etc. (in other words the "context") and, then loading the context of a new process or starting a new process from scratch which will have its own context. This technique allows the machine to concurrently execute multiple processes.</p>
         <p>This document handles stack management in context switch , specific to eXpOS implementation in XSM machine. There are two situations that can result in a context switch:</p>
	
	<p>&nbsp;&nbsp;&nbsp;1. While executing in the kernel mode (inside a system call or the exception handler), a process executes a blocking operation (like waiting for a file/disk). In this case, the process saves its own context and invokes the scheduler module to perform a context switch. </p>
	<p>&nbsp;&nbsp;&nbsp;2. The time slice of a process executing in the user mode expires and a timer interrupt (INT 1) is raised.  In this case, the timer interrupt routine saves the context of the current process and invokes the scheduler module.  </p>

	<br>

	In both these cases, the scheduler module need not save or restore the context of the callee as the callee saves its context before calling the scheduler module. See <a href=""> here </a>
	<br><br>
	
	<p> The calling conventions followed here correspond to the one given in the <a href="http://exposnitc.github.io/support_tools-files/spl.html" target="_blank">SPL documentation</a>.</p>
	<p><b>Important Note</b>: Whenever the kernel stack pointer of a process is saved in the KPTR field of the process table, the <b>offset of SP register within the user area page </b>will be stored (and <b>not</b> the physical address of the kernel stack pointer). The page number of the user area page is stored in the USER AREA PAGE NUMBER field in the process table. Thus, the value of the offset can be calculated by the fomula <i>offset = SP â€“ (512 * USER AREA PAGE NUMBER)</i>.</p>
	<p>The purpose of storing the offset (instead of the physical address) in the KPTR field is to allow the OS to relocate the user area page to another physical memory page. Thus, if the user area page is swapped out, it can be swapped back later to a different physical memory page.</p>
     
     </div>
	
<!--Kernel Mode begins-->

      <div class="container">
      	<div class="row">
	<p style="margin:0"><h4><b>Actions done by the scheduler: </b></h4></p>

&nbsp;&nbsp;&nbsp;1. Find the pid of the next process to be scheduled.<br> 
&nbsp;&nbsp;&nbsp;2. Save the current kernel stack pointer offset in the KPTR field of the process table.
<br><br>
	<div class="container-fluid .2.1_code fig_code">
 		<figure>
  			<div class="row">
   		 		<div class="col-sm-6">
     				<img src="../img/kernel_mode_timer_step1.ii.a.png" width="105%"></img>
    				</div>
    				<div class="col-sm-6">
    					<pre>
<b> Pseudo code</b>							
						<code>
...
						
MOV R4, User Area Page Number*512 
		// find the physical address 
        	   of the user area page
MOV R5, SP
SUB R5,R4
MOV KPTR,R5	// logicalSP = 
		   SP - (UAreaPgNo * 512)
...	
	   
						</code>
	
					</pre>
    				</div>
  			</div>
			<div class="row">
	 			<div class="col-sm-12">
	 				
					<figcaption><br><b>Fig.1.b - Storing the offset of kernel SP in the KPTR field of the process table.</b>
					</figcaption>
				</div>
			</div>
		</figure>
	</div>
<br><br>

&nbsp;&nbsp;&nbsp;3. Save the current PTBR and PTLR values in the process table of the leaving process. (Is this really required?)
<br>
&nbsp;&nbsp;&nbsp;4. Set the PTBR and PTLR values from the process table of the entering process.
<br>
&nbsp;&nbsp;&nbsp;5. Compute the physical address corresponding to the KPTR field of the process table of the entering process, and store this to SP.


	<div class="container-fluid .2.1_code fig_code">
 		<figure>
  			<div class="row">
   		 		<div class="col-sm-6">
     				<img src="../img/kernel_mode_timer_step2.i.a.png" width="105%"></img>
    				</div>
    				<div class="col-sm-6">
    					<pre>
						<code>
...
						
MOV R4, User Area Page Number*512
	// find the physical address of the user
	   area page 
ADD R4, KPTR
	// find the value of the kernel stack 
	   pointer using the formula 512*user 
	   area page number + KERNEL STACK POINTER
MOV SP, R4	
	// store the physical address of the kernel 
	   stack pointer in SP

...
					</code>
	
					</pre>
    				</div>
  			</div>
			<div class="row">
	 			<div class="col-sm-12">
	 				
					<figcaption><br><b>Fig.2.a - Setting the kernel SP from the offset value in the KPTR field of the process table. </b>
					</figcaption>
				</div>
			</div>
		</figure>
	</div>
<br><br><br>
	&nbsp;&nbsp;&nbsp;<p style="margin:0"><b>2.b. Actions done by the entering process (system call/exception routine) :</b></p><br>
	<p style="margin:0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.b.1. Restore the values of BP and registers in use from the kernel stack </p><br>
	<p style="margin:0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.b.2. Resume the execution of the system call routine </p><br><br>
	<div class="container-fluid .2.1_code fig_code">
 		<figure>
  			<div class="row">
   		 		<div class="col-sm-6">
     				<img src="../img/kernel_mode_timer_step2.ii.a.png" width="105%"></img>
    				</div>
    				<div class="col-sm-6">
    					<pre>
						<code>
...	
					
POP BP		//Pop and Save BP						
...		//Pop and Save the register values

(NOTE: The machine code above is in the form of pseudo code.)
						</code>
	
					</pre>
    				</div>
  			</div>
			<div class="row">
	 			<div class="col-sm-12">
	 				
					<figcaption><br><b>Fig.2.b - Actions done by the entering process (system call routine/exception handler): </b> Resume execution of the system call routine after restoring the BP and register values from the kernel stack.
					
					</figcaption>
				</div>
			</div>
		</figure>
	</div>
<br><br><br>

<!--User Mode begins-->

<div class="container">
      	<div class="row">
             	
		<p style="margin:0"><h4><b>3. When the leaving processs is in user mode </b></h4></p>
		&nbsp;&nbsp;&nbsp;<p style="margin:0">The following actions are performed by the scheduler (INT 1 routine) :<br><br>
		<p style="margin:0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.a. Switch from the user stack to the kernel stack </p><br>
		<p style="margin:0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.b. Use BACKUP instruction to save the context of the currently executing process </p><br>
		<p style="margin:0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.c. Store the logical kernel stack pointer in the KPTR field of the process table </p><br>
		<p style="margin:0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.d. Proceed to select the next process to run. </p><br><br>
		
	<div class="container-fluid .2.1_code fig_code">
 		<figure>
  			<div class="row">
   		 		<div class="col-sm-6">
     				<img src="../img/user_mode_timer_step1ab.png" width="105%"></img>
    				</div>
    				<div class="col-sm-6">
    					<pre>
						<code>
...

MOV UPTR, SP    
	// Save SP in the user stack pointer field 
	   of the process table
MOV R4, User Area Page Number*512
	// find the physical address of the user
	   area page 
ADD R4, KPTR
	// find the value of the kernel stack 
	   pointer using the formula 512*user 
	   area page number + KERNEL STACK POINTER
MOV SP, R4	
	// store the physical address of the kernel 
	   stack pointer in SP 
...

(NOTE: The machine code above is in the form of pseudo code.)
						</code>
	
					</pre>
    				</div>
  			</div>
			<div class="row">
	 			<div class="col-sm-12">
	 				
					<figcaption><br><b>Fig.3.a - Switch from the user stack to the kernel stack</b>
<p>3.a.1. Transfer the current SP register to User stack pointer field of the process table.</p>
<p>3.a.2.  Compute the physical address of the kernel stack pointer </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.a.2.1.  Find the physical address of the user area page (multiply the user area page number in the process table by 512) </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.a.2.2.  Find the value of the kernel stack pointer by adding the above value to the offset in kernel stack pointer field in process table.</p>
<p>3.a.3.  Transfer the physical address of the kernel stack pointer to the SP register.</p>
					</figcaption>
				</div>
			</div>
		</figure>
	</div>
<br><br><br><br>			

		<div class="container-fluid .2.1_code fig_code">
 		<figure>
  			<div class="row">
   		 		<div class="col-sm-6">
     				<img src="../img/user_mode_timer_step1cd.png" width="105%"></img>
    				</div>
    				<div class="col-sm-6">
    					<pre>
						<code>
...

BACKUP		// machine instruction to save the 
		   register context
MOV R4, User Area Page Number*512 
		// find the physical address 
        	   of the user area page
MOV R5, SP
SUB R5,R4
MOV KPTR,R5	// logicalSP = 
		   SP - (UAreaPgNo * 512)	 
		// Proceed with the scheduling 
		   code	
...
						

(NOTE: The machine code above is in the form of pseudo code.)
						</code>
	
					</pre>
    				</div>
  			</div>
			<div class="row">
	 			<div class="col-sm-12">
	 				
					<figcaption><br><b>Fig.3.{b,c,d} :</b>
					<p> 3.b. Save the context of the currently executing process using BACKUP instruction</p>
					<p> 3.c. Calculate the logical value of current SP pointing to kernel stack and store this in KPTR field in the process table</p>
					<p> 3.d. Proceed to select the next process to run</p>

					</figcaption>
				</div>
			</div>
		</figure>
	</div>
<br><br><br>


<p style="margin:0"><h4><b>4. When the entering process is in user mode </b></h4></p>
		&nbsp;&nbsp;&nbsp;<p style="margin:0">The following actions are performed by the scheduler (INT 1 routine) :<br><br>
		<p style="margin:0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.a. Set the value of SP to the  physical address of kernel stack pointer using KPTR </p><br>
		<p style="margin:0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.b. Use RESTORE instruction to load the context of the process </p><br>
		<p style="margin:0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.c. Save the logical address of current SP in the KPTR field of the process table  </p><br>
		<p style="margin:0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.d. Set the value of SP to the one stored in the UPTR field  </p><br>
		<p style="margin:0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.e. Transfer control to user process using <b>IRET</b> instruction (After the execution of the IRET instruction, the entering process will be executed in user mode) </p><br>
		<p style="margin:0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.f. Resume execution of the process </p><br><br>

		
	<div class="container-fluid .2.1_code fig_code">
 		<figure>
  			<div class="row">
   		 		<div class="col-sm-6">
     				<img src="../img/user_mode_timer_step2a.png" width="105%"></img>
    				</div>
    				<div class="col-sm-6">
    					<pre>
						<code>
...

MOV R4, User Area Page Number*512
	// find the physical address of the user
	   area page 
ADD R4, KPTR
	// find the value of the kernel stack 
	   pointer using the formula 512*user 
	   area page number + KERNEL STACK POINTER
MOV SP, R4	
	// store the physical address of the kernel 
	   stack pointer in SP 
...
						

(NOTE: The machine code above is in the form of pseudo code.)
						</code>
	
					</pre>
    				</div>
  			</div>
			<div class="row">
	 			<div class="col-sm-12">
	 				
					<figcaption><br><b>Fig.4.a - Compute the physical address of the kernel stack pointer </b>


<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.a.1.  Find the physical address of the user area page (multiply the user area page number in the process table by 512) </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.a.2.  Find the value of the kernel stack pointer by adding the above value to the offset in kernel stack pointer field in process table.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.a.3.  Transfer the physical address of the kernel stack pointer to the SP register.</p>
					</figcaption>
				</div>
			</div>
		</figure>
	</div>
<br><br><br><br>			

	<div class="container-fluid .2.1_code fig_code">
 		<figure>
  			<div class="row">
   		 		<div class="col-sm-6">
     				<img src="../img/user_mode_timer_step2b.png" width="105%"></img>
    				</div>
    				<div class="col-sm-6">
    					<pre>
						<code>
...

RESTORE	//To restore the context
	
...

(NOTE: The machine code above is in the form of pseudo code.)
						</code>
	
					</pre>
    				</div>
  			</div>
			<div class="row">
	 			<div class="col-sm-12">
	 				
					<figcaption><br><b>Fig.4.b : Use RESTORE instruction to restore the context of the process being scheduled in.</b>
					
					</figcaption>
				</div>
			</div>
		</figure>
	</div>
<br><br><br><br>


	<div class="container-fluid .2.1_code fig_code">
 		<figure>
  			<div class="row">
   		 		<div class="col-sm-6">
     				<img src="../img/user_mode_timer_step2c.png" width="105%"></img>
    				</div>
    				<div class="col-sm-6">
    					<pre>
						<code>
...
						
MOV R5, SP
SUB R5,R4
MOV KPTR,R5	// logicalSP = 
		   SP - (UAreaPgNo * 512)	 
IRET	
	    		   
....

(NOTE: The machine code above is in the form of pseudo code.)
						</code>
	
					</pre>
    				</div>
  			</div>
			<div class="row">
	 			<div class="col-sm-12">
	 				
					<figcaption><br><b>Fig.4.{c,d,e,f} : </b>
					<p>4.c. Switch from kernel stack to user stack</p>
					<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.c.1. Set the logical address of current SP to the KPTR field in the process table </p>
					<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.c.2. Set the value of SP to the one stored in the UPTR field </p>
					<p>4.d. Transfer control to user process using IRET instruction</p>
					<p>4.e. Resume execution of the process</p>
					</figcaption>
				</div>
			</div>
		</figure>
	</div>
	
<br><br><br><br>
         
 <!--=========== BEGIN FOOTER ================-->
     <footer id="footer">
       <div class="container">
         <div class="row">
           <div class="col-lg-6 col-md-6 col-sm-6">
             <div class="footer_left">
               <p><a href="http://www.nitc.ac.in/">National Institute of Technology, Calicut</a></p>
             </div>
           </div>
         </div>
       </div>
      </footer>
      <!--=========== END FOOTER ================-->

     <!-- Javascript Files
     ================================================== -->
  
     <!-- initialize jQuery Library -->
    <script src="../js/jquery.min.js"></script>
    <!-- Google map -->
    <script src="../js/map_js.js"></script>
    <script src="../js/jquery.ui.map.js"></script>
     <!-- For smooth animatin  -->
    <script src="../js/wow.min.js"></script> 
    <!-- Bootstrap js -->
    <script src="../js/bootstrap.min.js"></script>
    <!-- superslides slider -->
    <script src="../js/jquery.superslides.min.js" type="text/javascript"></script>
    <!-- slick slider -->
    <script src="../js/slick.min.js"></script>    
    <!-- for circle counter -->
    <script src='../js/jquery.circliful.min.js'></script>
    <!-- for portfolio filter gallery -->
    <script src="../js/modernizr.custom.js"></script>
    <script src="../js/classie.js"></script>
    <script src="../js/elastic_grid.min.js"></script>
    <script src="../js/portfolio_slider.js"></script>

    <!-- Custom js-->
    <script src="../js/custom.js"></script>
  </body>
</html>
