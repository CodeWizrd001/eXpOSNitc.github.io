<!--Process manager-->
		<div id="process" class="row">
        
            
            <div class="heading">
              <h2>Module 1: Process Manager</h2>
               <br>
                            <br>
              <p>int GetPcbEntry() {
				   Returns the index of a free PCB entry after searching the process table.
				}

				int FreePcbEntry(int PID) {
					Releases files, semaphores and locks if any, releases pages, swap blocks, and any other resources
				held by the process.   Must not be invoked if the process is blocked.  
				}
			</p>
								           
                  
        	</div>
        </div>
	
		<!--Device manager-->
		<div id="device" class="row">
        
            
            <div class="heading">
              <h2>Module 4: Device Manager</h2>
               <br>
                            <br>
              <p>
				int Dwrite(page#, block#) {
				   Block for acquiring the disk; transfers contents of page# to disk block#;
				   block for the transfer to complete and returns success;   
				}

				int Dread(block#,page#) {  
					Acquire the disk, transfers contents of disk block# to page#; block for the 
					transfer to complete and return success;    
				}

				int Twrite(data) {
					Writes data into the terminal (non-blocking);
				}

				int Tread(bufferptr) {
				   Block for the terminal; read data and transfer to buffer;  
				} 
			</p>
								           
                  
        	</div>
        </div>


		<!--File buffer manager-->
		<div id="filebuffer" class="row">
        
            
            <div class="heading">
              <h2>Module 3: File Buffer Manager</h2>
               <br>
                            <br>
              <p>
				/* The buffer manager hides the buffer from the system call routine!  */
				/* Uses devvice manager routines Dread and Dwrite below */

				Bufwrite(disk#,offset,data) {
				  Wait for the buffer and lock it.
				  If the disk# is already not present in the buffer, Dread the disk block to the buffer cache; if necessary by replacing exisiting page and write data to the offset.  
				}

				Bufread(disk#,offset,data) {
				   Wait for the buffer and lock it
				   If the disk# is already not present in the buffer,   Dread the disk block into buffer cache, if necessary by replacing existing page and return data at the offset.  
				}

			</p>
								           
                  
        	</div>
        </div>

		<!--Memory manager-->
		<div id="memory" class="row">
        
            
            <div class="heading">
              <h2>Module 2: Memory Manager</h2>
               <br>
                            <br>
              <p>
				  int Getpage() {
				  Runs the second chance algorithm if necessary and returns the page# of a free memory page.
				}

				int Releasepage(page#) {
				  Releases the page, updates memory free list, system status table  and returns success;  
				}

			</p>
								           
                  
        	</div>
        </div>
		<!--Context Switch module-->
		<div id="contextswitch" class="row">
        
            
            <div class="heading">
              <h2>Module 5: Context Switch Modue</h2>
               <br>
                            <br>
              <p>
					Switch_Context()  {

				   Saves the context of the current process,  set the process to the context of the “next pid” in the system status table; update “next pid” to the next process which is “schedulable”  (that is stack is in memory).  All except SP, BP and IP are set.  If the disk controller is free and memory is available, a swap in can be initiated to any process which is skipped because of “non-schedulability”).  If nothing better, idle process will be set.  Actual scheduling is not done here.  Only set up work (except for SP, and IP) is completed.    Actual context swich will be done from the interrupt handler/timer, which typically invokes this module before the context switch.  

				}

			</p>
								           
                  
        	</div>
        </div>

