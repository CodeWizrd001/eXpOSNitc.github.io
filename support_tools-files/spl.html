<!DOCTYPE html>
<html lang="en">
  <head>

    <!-- Basic Page Needs
    ================================================== -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
     <title>SPL</title>

    <!-- Mobile Specific Metas
    ================================================== -->
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Favicon -->
    <link rel="shortcut icon" type="image/png" href="../img/favicon.jpg"/>

    <!-- CSS
    ================================================== -->       
    <!-- Bootstrap css file-->
    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <!-- Font awesome css file-->
    <link href="../css/font-awesome.min.css" rel="stylesheet">
    <!-- Superslide css file-->
    <link rel="stylesheet" href="../css/superslides.css">
    <!-- Slick slider css file -->
    <link href="../css/slick.css" rel="stylesheet"> 
    <!-- smooth animate css file -->
    <link rel="stylesheet" href="../css/animate.css">  
    <!-- Elastic grid css file -->
    <link rel="stylesheet" href="../css/elastic_grid.css"> 
    <!-- Circle counter cdn css file -->
    <link rel='stylesheet prefetch' href='../css/jquery.circliful.css'>    
    <!-- Default Theme css file -->
    <link id="orginal" href="../css/themes/eucalyptus-theme.css" rel="stylesheet">
    <!-- Main structure css file -->
    <link href="../style.css" rel="stylesheet">
   
    <!-- Google fonts -->
    <link href='../css/opensans.css' rel='stylesheet' type='text/css'>
    <link href='../css/varela.css' rel='stylesheet' type='text/css'>
    <link href='../css/montserrat.css' rel='stylesheet' type='text/css'>

  </head>
  <body> 
     <!-- BEGAIN PRELOADER -->
    <div id="preloader">
      <div id="status">&nbsp;</div>
    </div>
    <!-- END PRELOADER -->

  
    <!--=========== BEGIN HEADER SECTION ================-->
    <header id="header">
      <!-- BEGIN MENU -->
      <div class="menu_area">
        <nav class="navbar navbar-default navbar-fixed-top past-main" role="navigation"> 
          <div class="container">
          <div class="navbar-header">
            <!-- FOR MOBILE VIEW COLLAPSED BUTTON -->
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

              <!-- LOGO -->

            <!-- TEXT BASED LOGO -->
            <a class="navbar-brand" href="../index.html">eXpOS<span>NITC</span></a>
            
                              
          </div>
          <div id="navbar" class="navbar-collapse collapse">
            <ul id="top-menu" class="nav navbar-nav navbar-right main_nav">
              <li><a href="../index.html">Home</a></li>
              <li><a href="../Roadmap.html" target="_blank">Roadmap</a></li>
              <li><a href="../Documentation.html" target="_blank">Documentation</a></li> 
               <li><a href="../Downloads.html" target="_blank">Downloads</a></li> <!--Change here--> 
               <li><a href="../faq.html" target="_blank">FAQ</a></li>
              <li><a href="../About_us.html" target="_blank">About Us</a></li>                                     
            </ul>           
          </div>
          </div>     
        </nav>  
      </div>
      <!-- END MENU -->


      
    </header>
		<!--=========== End HEADER SECTION ================--> 
		
		
       <section id="expfs">
		<br>
		<br>
		<br>
      <div class="container">
        <div class="row">
          <div class="col-lg-12 col-md-12">
            <div class="about_area">
             
                <!-- START ABOUT HEADING -->
              <div class="heading">
                <h2 >SPL Specification</h2>
                <br/>
                <br/>
               
                  
                  <p><b>SPL</b> or <i>System Programmer's Language</i> in reality is not a high level programming language, but an enhanced assembly language programming system for writing protected mode programs for the XSM machine.  This language is useful for implementation
of an OS on top of the XSM machine.  The language is minimalistic and consists only of very basic constructs. 
                    Programming using SPL requires an understanding of the underlying <a href="../arch_spec.html" target="_blank" >XSM architecture</a>.  
<p>
Each SPL program is considered as a <b>module</b>.  A module consists of a maximum of 1024 words which includes both
the space allocated for code and data.    
The SPL compiler translates an SPL source program to a target XSM assembly module. <a href="../support_tools-files/xfs-interface.html" target="_blank" >(See Loading modules into the disk architecture)</a>.  </p>  

<p>This specification defines the syntax and semantics of the basic constructs of the SPL language and also specifies
the programming conventions recommended in using the langugage.  The default SPL compiler provided as part of the 
eXpOS package is designed to follow the programming conventions specified in this document.   </p>
                  
                  
              </div>

              <!-- START ABOUT CONTENT -->
              <div class="about_content">
                <div class="row">
                   <div class="about_featured">
                      <div class="panel-group" id="accordion">
                        <!-- START SINGLE FEATURED ITEM #1-->
                        <div class="panel panel-default ">
                          <div class="panel-heading">
                            <h4 class="panel-title">
                              <a data-toggle="collapse" href="#c1">
                                 <span class="fa fa-check-square-o"></span>Lexical Elements
                              </a>
                            </h4>
                          </div>
                          <div id="c1" class="panel-collapse collapse">
                            <div class="panel-body">
                             
                                <h3>Comments and White Spaces</h3>
                                <p> SPL allows only single line comments. Comments start with the character sequence // and stop at the end of the line. </p>
				<p>White spaces in the program including tabs, newline and horizontal spaces are ignored.</p>
                                
    <h3>Keywords</h3>
				<p>	The following are the reserved words in SPL and it cannot be used as identifiers.
				<tt>
				<pre><table style="text-align:center; width:50%;">
					<tr><td>alias </td> <td>define</td> <td>encrypt</td> <td>breakpoint</td> <td>inline</td></tr>
                    <tr><td>halt</td> <td>goto</td> <td>call</td> <td>return</td> <td>ireturn</td></tr>
                    <tr><td>backup</td> <td>restore</td> <td>read</td> <td>reada</td> <td>print</td></tr>
                    <tr><td>load</td> <td>loada</td> <td>store</td> <td>storea</td> <td>while</td></tr>
                    <tr><td>do</td> <td>endwhile</td> <td>break</td> <td>continue</td> <td>if</td></tr>
					<tr><td>then</td> <td>else </td> <td>endif</td> <td>var</td> <td>endvar</td></tr>
                    
				</table></pre>
				</tt></p>
                                <h3>Operators and Delimiters</h3>
				<p>	The following are the operators and delimiters in SPL
				<pre><table style="text-align:center; width:50%">
					<tr> <td>(</td> <td>)</td> <td>;</td> <td>[</td> <td>]</td> <td>/</td> <td>*</td> <td>+</td> <td>-</td> <td>%</td><td>:</td> </tr>
					<tr> <td>></td> <td><</td> <td>>=</td> <td><=</td> <td>!=</td> <td>==</td> <td>=</td> <td>&&</td> <td>||</td> <td>!</td> </tr>
				</table></pre>
				</p>
                <h3>Registers and Ports</h3>
                              <p>	SPL allows the use of 25 registers (<tt>R0-R15, BP, SP, IP, PTBR, PTLR, EIP, EC, EPN, EMA</tt>) and 4 ports (<tt>P0-P3</tt>). P0 and P1 are used for standard input and standard output respectively.</p>                     
                <h3>Identifiers</h3>
				<p>	Identifiers are used as symbolic names for constants and aliases for registers.
				Identifiers should start with an alphabet but may contain alphabets, digits and/or underscore ( _ ). 
				No other special characters are allowed in identifiers.</p>
				<p> <i>Examples:</i></p><p><b>Valid :</b> <tt>var1</tt>, <tt>new_page</tt> </p>
					<p><b>Invalid :</b> <tt> 9blocks</tt>, <tt>$n</tt> etc.</p></p>
                          
                <h3>Literals</h3>
                            <p>	Integer and String literals are permitted in SPL.</p><p> An integer literal is a sequence of digits representing an integer. 
				Negative integers are represented with a negative sign preceding the sequence of digits.  eg. <tt>3, -512, 1024</tt>
				<p>A string literal is a sequence of characters which are enclosed within double quotes (" ").
				  eg. <tt> "alice"</tt>

				</p>
                <h3>Labels</h3>
                     <p>	SPL supports labels which are used along with <tt>goto</tt> and <tt>call</tt>. Labels follow the same naming convention as that of the identifiers.<br/>
                                eg. <tt>label1:<br/> .<br/> .<br/> .<br/> goto label1</tt></p>
                            </div>
                          </div>
                        </div>   
                    
                    
                    
                        <!-- START SINGLE FEATURED ITEM #2 -->
                        <div id="root">
                        <div class="panel panel-default "> 
                          <div class="panel-heading">
                            <h4 class="panel-title">
                              <a data-toggle="collapse" href="#c2">
                                 <span class="fa fa-check-square-o"></span>Registers and Ports
                              </a>
                            </h4>
                          </div>
                          <div id="c2" class="panel-collapse collapse">
                            <div class="panel-body">
                            <p>	SPL provides a fixed set of registers and ports are provided. 
                                The register set in SPL contains 29 registers. There is a direct mapping between these registers and the machine registers in XSM. There are 4 ports supported.</p>
			
			<table class="table table-bordered" style="text-align: center;">
                <tr class="success">
                                        <th style="text-align: center;">Name</th>
                                        <th style="text-align: center;">Register/Port</th>
                                    </tr>
					<tr> <td>Program Registers</td> <td>R0 - R15</td> </tr>
                    <tr> <td>Reserved Registers<br/><b style="font-size:12px">(For the use of SPL compiler)</b></td> <td>R16 - R19</td> </tr>
					<tr> <td>Base Pointer</td> <td>BP </td> </tr>
					<tr> <td>Stack Pointer</td> <td>SP</td> </tr>
					<tr> <td>Instruction Pointer</td> <td>IP </td> </tr>
					<tr> <td>Page Table Base Register</td> <td>PTBR </td> </tr>
					<tr> <td>Page Table Length Register</td> <td>PTLR </td> </tr>
					<tr> <td>Exception Instruction Pointer</td> <td>EIP </td> </tr>
                    <tr> <td>Exception Cause</td> <td>EC </td> </tr>
                    <tr> <td>Exception Page Number</td> <td>EPN </td> </tr>
                    <tr> <td>Exception Memory Address</td> <td>EMA </td> </tr>
                    <tr> <td>Input Port</td> <td>P0</td> </tr>
                    <tr><td>Output Port</td> <td>P1</td> </tr>
                    <tr><td>Unused Ports</td> <td>P2, P3</td> </tr>
				</table>   
                
                <h3>Aliasing</h3>
				<p>	Any register/port can be referred to by using a different name. A name is assigned to a particular register/port using the <b>alias</b> keyword. 
				Each register/port can be assigned to only one alias at any particular point of time. However, a register/port can be reassigned to a different alias at a later point. 
				Aliasing can also be done inside the <b>if</b> and <b>while</b> block. However, an alias defined within the <b>if</b> and <b>while</b> blocks will only be valid within the block.  No two registers/ports can have the same alias name simultaneously.</p>
                                
                            </div>
                          </div>
                        </div>
                        </div>
                        <!-- START SINGLE FEATURED ITEM #3 -->
                        <div class="panel panel-default ">
                          <div class="panel-heading">
                            <h4 class="panel-title">
                              <a data-toggle="collapse" href="#c3">
                                <span class="fa fa-check-square-o"></span>Constants
                              </a>
                            </h4>
                          </div>
                          <div id="c3" class="panel-collapse collapse">
                            <div class="panel-body">
                                <p>	Symbolic names can be assigned to values using the <b>define</b> keyword. 
				Unlike aliasing, two or more names can be assigned to the same value. 
				A constant can only be defined once in a program.</p>
                                <h3>Predefined Constants</h3>
				<p>	SPL provides a set of predefined constants. 
				These predefined constants can be assigned to different values explicitly by the user using <b>define</b> keyword.
                    These constants are mostly the starting addresses of various OS data structures/handlers in the memory which are specified <a href="../os_implementation.html">here</a>. They are specifically tuned for the eXperimental Operating System which runs on the XSM architecture.</p>
                                <p><code>Note: </code> Pre-defined constants are actually not part of the language specification, but included in the version of SPL provided here as support for the <a href="../os_implementation.html" target="_blank">implementation</a> of eXpOS operating system in SPL. </p>
				<p>The predefined set of constants provided in SPL are:</p>
                                <table class="table table-bordered" style="text-align: center;">
                <tr class="success">
                                        <th style="text-align: center;">Name</th>
                                        <th style="text-align: center;">Default Value</th>
                                        <th style="text-align: center;">Comments</th>
                                    </tr>
                    <tr> <td>INODE_TABLE</td> 	<td>...</td><td></td> </tr>
                    <tr> <td>DISK_FREE_LIST</td> 	<td>...</td><td></td> </tr>
                    <tr> <td>ROOT_FILE</td> 	<td>...</td><td></td> </tr> 
                    <tr> <td>USER_TABLE</td> 	<td>...</td><td></td> </tr>  
                    <tr> <td>PROCESS_TABLE</td> 	<td>...</td><td></td> </tr>
                    <tr> <td>FILE_TABLE</td> 	<td>...</td><td></td></tr>  
                    <tr> <td>SEMAPHORE_TABLE</td> 	<td>...</td><td></td> </tr> 
                    <tr> <td>DISK_STATUS_TABLE</td> 	<td>...</td><td></td> </tr>  
                    <tr> <td>BUFFER_TABLE</td> 	<td>...</td><td></td> </tr> 
                    <tr> <td>SYSTEM_STATUS_TABLE</td> 	<td>...</td><td></td> </tr>
                    <tr> <td>TERMINAL_STATUS_TABLE</td> 	<td>...</td><td></td> </tr> 
                    <tr> <td>MEMORY_FREE_LIST</td> 	<td>...</td><td></td> </tr>   
                    <tr> <td>EXCEPTION</td> 	<td>...</td><td></td> </tr>
					<tr> <td>TIMER</td> 	<td>...</td><td></td> </tr>
                    <tr> <td>DISK</td> 	<td>...</td><td></td> </tr>  
                    <tr> <td>CONSOLE</td> 	<td>...</td><td></td> </tr>
                    <tr> <td>INT_4</td> 	<td>...</td><td>(Create, 1)<code><sup>*</sup></code>, (Delete, 4), (Seek, 6)</td> </tr>
                    <tr> <td>INT_5</td> 	<td>...</td><td>(Open, 2), (Close,3)</td> </tr>
                    <tr> <td>INT_6</td> 	<td>...</td><td>(Read, 7)</td> </tr>
                    <tr> <td>INT_7</td> 	<td>...</td><td>(Write, 5)</td> </tr>
                    <tr> <td>INT_8</td> 	<td>...</td><td>(Fork, 8)</td> </tr>
                    <tr> <td>INT_9</td> 	<td>...</td><td>(Exec, 9)</td> </tr>
                    <tr> <td>INT_10</td> 	<td>...</td><td>(Exit, 10)</td> </tr>
                    <tr> <td>INT_11</td> 	<td>...</td><td>(Getpid, 11), (Getppid, 12), (Wait, 13), (Signal, 14)</td> </tr>
                    <tr> <td>INT_12</td> 	<td>...</td><td>(FLock, 15), (FUnLock, 16)</td> </tr>
                    <tr> <td>INT_13</td> 	<td>...</td><td>(Semget, 17), (Semrelease, 18)</td> </tr>
                    <tr> <td>INT_14</td> 	<td>...</td><td>(SemLock, 19), (SemUnLock, 20)</td> </tr>
                    <tr> <td>INT_15</td> 	<td>...</td><td>(Shutdown, 21)</td> </tr>
                    <tr> <td>INT_16</td> 	<td>...</td><td></td> </tr>
                    <tr> <td>INT_17</td> 	<td>...</td><td></td> </tr>
                    <tr> <td>INT_18</td> 	<td>...</td><td>(Test, 99)</td> </tr>
                    <tr> <td>MOD_0</td> 	<td>...</td><td></td> </tr>
                    <tr> <td>MOD_1</td> 	<td>...</td><td></td> </tr>
                    <tr> <td>MOD_2</td> 	<td>...</td><td></td> </tr>
                    <tr> <td>MOD_3</td> 	<td>...</td><td></td> </tr>
                    <tr> <td>MOD_4</td> 	<td>...</td><td></td> </tr>
                    <tr> <td>MOD_5</td> 	<td>...</td><td></td> </tr>
                    <tr> <td>MOD_6</td> 	<td>...</td><td></td> </tr>
                    <tr> <td>MOD_7</td> 	<td>...</td><td></td> </tr>                
                    <tr> <td>DISK_SWAP_AREA</td> 	<td>...</td><td></td> </tr>                
					<!--tr> <td>SCRATCHPAD</td> 	<td>512</td> </tr>
					<tr> <td>PAGE_TABLE</td> 	<td>1024</td> </tr>
					<tr> <td>MEM_LIST</td> 		<td>1280</td> </tr>
					<tr> <td>FILE_TABLE</td> 	<td>1344 </td> </tr>
					<tr> <td>PROCESS_TABLE</td> 	<td>1536</td> </tr>
					<tr> <td>INODE_TABLE</td>  <td>2560 </td> </tr>
					<tr> <td>DISK_LIST</td> 	<td>3072 </td> </tr>
					<tr> <td>EXCEPTION</td> 	<td>3584 </td> </tr>
					<tr> <td>TIMER</td> 	<td>4608 </td> </tr>
                    <tr> <td>DISK</td> 	<td>4608 </td> </tr>
                    <tr> <td>CONSOLE</td> 	<td>4608 </td> </tr>
					<tr> <td>INTERRUPT</td> 	<td>5632 </td> </tr>
					<tr> <td>USER_PROG</td> 	<td>12800 </td> </tr>
                    <tr> <td>DISK_BUFFER</td> 	<td>.... </td> </tr!-->              
				</table>   
                <code>*</code>(System Call Name, System Call Number)                
                 
                            </div>
                          </div>
                        </div>
                        <!-- START SINGLE FEATURED ITEM #var -->
                        <div class="panel panel-default ">
                          <div class="panel-heading">
                            <h4 class="panel-title">
                              <a data-toggle="collapse" href="#var">
                                <span class="fa fa-check-square-o"></span>Variables
                              </a>
                            </h4>
                          </div>
                          <div id="var" class="panel-collapse collapse">
                            <div class="panel-body">
                                <p>Variables are declared within the keywords <b>var</b> and <b>endvar</b>.  A variable declared in a program
module can be accessed in the module, but will not be visible in other modules. </p>
                                <p> Declarations must precede
program statements. Variables follow the same naming convention as that of the identifiers. Format of variable declaration is given below.
                                </p>
<pre>
var
a,b,c
endvar
</pre>
<p><code>Note: </code>Variables must be allocated only if registers R0 to R15 are exhausted,  because  a register access is faster than memory access.</p>                                

                                    
                            </div>
                          </div>
                        </div>
                    <!--end item var-->    
                        
                        <!-- START SINGLE FEATURED ITEM #4 -->
                        <div class="panel panel-default ">
                          <div class="panel-heading">
                            <h4 class="panel-title">
                              <a data-toggle="collapse" href="#c4">
                                <span class="fa fa-check-square-o"></span>Expressions
                              </a>
                            </h4>
                          </div>
                          <div id="c4" class="panel-collapse collapse">
                            <div class="panel-body">
                                <p>	An expression specifies the computation of a value by applying operators to operands. SPL supports arithmetic and logical expressions.</p>
                                
                                <h3>Arithmetic Expressions</h3>
				<p>	Registers, constants, variables and two or more arithmetic expressions connected using arithmetic operators are categorized as arithmetic expressions. 
                    SPL provides five arithmetic operators, viz., <b>+, -, *, /</b> (Integer Division) and <b>%</b> (Modulo operator) through which arithmetic expressions may be combined. 
				Expression syntax and semantics are similar to standard practice in programming languages and normal rules of precedence, associativity and paranthesization hold.</p>
                                <p><i>Examples:</i></p><p><tt>(5*R4) + 3</tt> </p><p> <tt>10 % 4</tt></p>
			
			
				<h3>Logical Expressions</h3>
				<p>	Logical expressions may be formed by combining arithmetic expressions using relational operators. 
				The relational operators supported by SPL are  <b><tt>
                    >, <, >=, <=, !=, ==</tt></b>.
				Standard meanings apply to these operators. A relational operator will take in two arguments and return 1 if the relation is valid and 0 otherwise. <br/>
                    <p>The relational operators can also be applied to strings. <tt> <, >, <=, >= </tt> compares two strings lexicographically. <tt>!= </tt> and <tt>==</tt> checks for equality in the case of strings. If one of the operands is a string, the other operand will also be considered as a string.</p>
                        <p><i>Examples:</i></p>
                        <p>
				 <p><tt> "adam" < "apple"      // This returns 1 </tt></p>
				 <p><tt> "hansel" == "gretel"     // This returns 0 </tt></p>
                <p><tt> "3" == 3     // This returns 1, as 3 will be treated as "3" </tt></p>        
				<p>Logical expressions themselves may be combined using logical operators, && (logical and) , || (logical or) and ! (not).</p>
						
			
				<h3>Addressing Expressions</h3>
				<p>	Memory of the machine can be directly accessed in an SPL program. 
                    A word in the memory is accessed by specifying the addressing element, i.e. memory location within <b>[ ]</b>. 
				This corresponds to the value stored in the given address. An arithmetic expression or an addressing expression can be used to specify the address.<br/>
                        <p><i>Examples :</i></p>
				<p><tt>[1024], [R3], [R5+[R7]+128], [INODE_TABLE + R2] </tt>etc.</p>
			
                                    
                                    
                            </div>
                          </div>
                        </div>
                    <!--end item 4-->    
                        
                     <!-- START SINGLE FEATURED ITEM #5 -->
                        <div class="panel panel-default ">
                          <div class="panel-heading">
                            <h4 class="panel-title">
                              <a data-toggle="collapse" href="#c5">
                                <span class="fa fa-check-square-o"></span>Statements
                              </a>
                            </h4>
                          </div>
                          <div id="c5" class="panel-collapse collapse">
                            <div class="panel-body">
                                <p>	Statements control the execution of the program. All statements in SPL are terminated with a semicolon <b>( ; )</b> .</p>    
                                <h3>Define Statement</h3>
                                <p>	The <b>define</b> statement is used to define a symbolic name for a value. Define statements should be used <b>before any other statement</b> in an SPL program. 
				The keyword <b>define</b> is used to associate a literal to a symbolic name.<br/>		
                    <tt>&nbsp;&nbsp;&nbsp; <b>SYNTAX :</b> <b>define</b> constant_name value;</tt></p>
				<pre>
                define DISK_BLOCK 437;</pre>
                                
                <h3>Alias Statement</h3>
				<p>	An <b>alias</b> statement is used to associate a register/port with a name. Alias statements can be used anywhere in the program.<br/>
				
				<tt>&nbsp;&nbsp;&nbsp; <b>SYNTAX :</b> <b>alias</b> alias_name register_name;</tt></p>
			    <pre>
                alias counter R0;</pre>
				                 
                <h3>Breakpoint Statement</h3>
                                <p>	The <b>breakpoint</b> statement is used to debug the program. The program when run in the <a href="xsm-simulator.html" target="_blank" >debug mode</a> pauses the execution at this instruction.<br/>
				
					<tt>&nbsp;&nbsp;&nbsp; <b>SYNTAX :</b><b>breakpoint</b>;</tt>
                                </br> This statement translates to <a href="../arch_spec-files/instruction_set.html" target="_blank">BRKP machine instruction</a>.</p>
                
                <h3>Assignment Statement</h3>
				<p>	The SPL assignment statement assigns the value of an expression/value stored in a memory address to a register/memory address. 
				<b>=</b> is the assignment operator used in SPL. The operand on the right hand side of the operator is assigned to the left hand side. 
				<br/>
				
				<tt>&nbsp;&nbsp;&nbsp; <b>SYNTAX : </b> Register / Variable / Alias / [Address] = Register / Port / Variable / Number / String / Expression / [Address];</tt></p>
			 <pre>
				R2 = P0; <br/>
				counter = counter + 1; <br/>
				[PTBR + 3] = [1024] + 10; <br/>
				R1 = "hello world"; <br/>
            </pre>
               
                <h3>If Statement</h3>
				<p>	<b>If</b> statement specifies the conditional execution of two branches according to the value of a logical expression. 
				If the expression evaluates to 1, the <b>if</b> branch is executed, otherwise the <b>else</b> branch is executed. The <b>else</b> part is optional. <br/>
				
				<tt>&nbsp;&nbsp;&nbsp; <b>SYNTAX : </b> <br/></p>
				<p><b>if</b> (logical expression) <b>then</b><br/>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statements;<br/>
				<b>&nbsp;&nbsp;&nbsp; else</b><br/>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statements;<br/>
				<b>&nbsp;&nbsp;&nbsp; endif</b>;</tt></p>            
                
                <h3>While Statement</h3>
				<p>	<b>While</b> statement iteratively executes a set of statements based on a condition. 
				The condition is defined using a logical expression. 
				The statements are iteratively executed as long as the condition is true.<br/>
				
				<tt>&nbsp;&nbsp;&nbsp; <b>SYNTAX : </b></p>
				<p><b>while</b> (logical expression) <b>do</b><br/>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statements;<br/>
				<b>&nbsp;&nbsp;&nbsp; endwhile</b>;</tt></p> 
                            
                <h3>Break Statement</h3>
				<p>	<b>Break</b> statement when used inside a while loop block, stops the execution of the loop in which it is used and passes the control of execution to the next statement after the loop. 
				This statement cannot be used anywhere else other than while loop.<br/>
				
					<tt>&nbsp;&nbsp;&nbsp; <b>SYNTAX : </b><b>break</b>;</tt></p>    
                
                <h3>Continue Statement</h3>
				<p>	<b>Continue statement</b> when used inside a while loop block, skips the current iteration of the loop and passes the control to the next iteration after checking the loop condition. <br/>
					
					<tt>&nbsp;&nbsp;&nbsp; <b>SYNTAX : </b><b>continue</b>;</tt></p>  
                            
                <h3>Ireturn Statement</h3>
				<p>	<b>ireturn</b> statement or the Interrupt Return statement is used to pass control from a kernel mode interrupt service routine to the user mode program which invoked it.<br/>
                    <tt>&nbsp;&nbsp;&nbsp; <b>SYNTAX : </b><b>ireturn</b>;</tt><br/></p>
                    <p>The <b>ireturn</b> is generally used at the end of an interrupt code. This statement translates to <a href="../arch_spec-files/instruction_set.html" target="_blank">IRET machine instruction</a>.</p>
                
                <h3>Read/Print Statements</h3>
				<p>	The <b>read</b> and <b>print</b> statements are used as standard input and output statements. The <b>read</b> statement reads a value from the standard input device and stores it in a register. 
					<p><code>Note :</code> String read or printed must not exceed 10 characters.</p>
					The <b>print</b> statement outputs value of a register or an integer/string literal or value of a memory location.<br/>
                     
                    <tt>&nbsp;&nbsp;&nbsp; <b>SYNTAX : </b></p>
				    <p><b>read</b> Register;<br/>
				    &nbsp;&nbsp;&nbsp;&nbsp;<b>print</b> Register / Variable / Number / String / Expression / [Address];</tt></p>   

                
                <h3>Reada Statement</h3>
				<p>	The <b>reada</b> statement initiates the transfer of a string from the console to the standard input port P0 using the INA machine instruction. The machine proceeds to execute the next instruction without waiting for the completion of the string transfer.</p>
					<p><code>Note :</code> String read must not exceed 10 characters.</p>
					
                     
                    <tt>&nbsp;&nbsp;&nbsp; <b>SYNTAX : </b>
				    <b>reada</b>;<br/></tt>  
                                
                    <h3>Loada/Storea Statements</h3>
				<p>	Loading and storing between the disk and the memory of the XSM machine can be accomplished using <b>loada</b> and <b>storea</b> statements in SPL. The machine proceeds to execute the next instruction without waiting for the completion of the block transfer. 
				<p><b>loada</b> statement loads the block specified by <i>block_number</i> from the disk to the the page specified by the <i>page_number</i> in the memory. 
				<b>storea</b> statement stores the page specified by <i>page_number</i> in the memory to the the block specified by the <i>block_number</i> in the disk.
				The <i>page_number</i> and <i>block_number</i> can be specified using arithmetic expressions.</p>
				
                <tt>&nbsp;&nbsp;&nbsp; <b>SYNTAX : </b></p>     
				<p><b>loada</b> (page_number, block_number);<br/>
					&nbsp;&nbsp;&nbsp;&nbsp;<b>storea</b> (page_number, block_number);</tt></p>
                
                
                <h3>Load/Store Statement</h3>
				<p>	Loading and storing between the disk and the memory of the XSM machine can also be accomplished using <b>load</b> and <b>store</b> statements in SPL. But here, the machine will continue execution of the next instruction only after the block transfer is completed.
                    <p><b>load</b> statement loads the block specified by <i>block_number</i> from the disk to the the page specified by the <i>page_number</i> in the memory. 
				<b>store</b> statement stores the page specified by <i>page_number</i> in the memory to the the block specified by the <i>block_number</i> in the disk.
				The <i>page_number</i> and <i>block_number</i> can be specified using arithmetic expressions.</p>
				
                <tt>&nbsp;&nbsp;&nbsp; <b>SYNTAX : </b></p>     
				<p><b>load</b> (page_number, block_number);<br/>
					&nbsp;&nbsp;&nbsp;&nbsp;<b>store</b> (page_number, block_number);</tt></p>
          
                 <h3>Backup Statement</h3>
           <p>The <b>backup</b> statement is used to backup all the machine registers (except SP, IP, exception flag registers and ports) into the memory locations starting from the address pointed to by SP in the order : BP, PTBR, PTLR, R0 - R19. The value of SP gets incremented accordingly.</p>
				
                    <p><tt><b>SYNTAX : </b><b>backup</b>;</tt></p>
				<p>This statement translates to the <a href="../arch_spec-files/instruction_set.html" target="_blank">BACKUP machine instruction</a>.</p>
                <h3>Restore Statement</h3>
           <p>The <b>restore</b> statement is used to restore the backed up machine registers from the memory. The registers are restored from contiguous memory locations starting from the address pointed to by SP in the order : R19-R0, PTLR, PTBR, BP. The value of SP gets decremented accordingly.  </p>
				
                    <p><tt><b>SYNTAX : </b><b>restore</b>;</tt></p>
				<p>This statement translates to the <a href="../arch_spec-files/instruction_set.html" target="_blank">RESTORE machine instruction</a>.</p>
           
                <h3>Encrypt Statement</h3>
           <p> The <b>encrypt</b> statement replaces the value in the register Ri with its encrypted value. 
          </p>
				
                    <p><tt><b>SYNTAX : </b><b>encrypt Ri</b>;</tt></p>
				<p>This statement translates to the <a href="../arch_spec-files/instruction_set.html" target="_blank">ENCRYPT machine instruction</a>.</p>
                  <h3>Goto Statement</h3>
           <p> The <b>goto</b> statement transfers control to the specified labelled statement.</p>
				
                    <p><tt><b>SYNTAX : </b><b>goto label / INT_n / MOD_n </b>;</tt></p>
                    <pre>
                        goto label1;
                        goto INT_7;
                        goto MOD_2;</pre>    
           <p><code>Note: </code><tt>label</tt> should be defined within the module.</p>
            <h3>Call Statement</h3>
           <p> The <b>call</b> statement saves procedure linking information on the stack and branches to the procedure specified by the argument.</p>
				
                    <p><tt><b>SYNTAX : </b><b>call label / INT_n / MOD_n </b>;</tt></p>
                    <pre>
                        call swap_func;
                        call INT_7;
                        call MOD_2;</pre>
           <p><code>Note: </code><tt>label</tt> should be defined within the module.</p>
           <p>Call statement translates to the <a href="../arch_spec-files/instruction_set.html" target="_blank">CALL machine instruction</a>.</p>
            <h3>Return Statement</h3>
           <p> The <b>return</b> statement is used to transfer the control from a subroutine to the calling program in the kernel mode and the return address is popped from the stack.</p>
				
                    <p><tt><b>SYNTAX : </b><b>return</b>;</tt></p>
                <p>This statement translates to the <a href="../arch_spec-files/instruction_set.html" target="_blank">RET machine instruction</a>.</p>
                        
                </span>
                <h3>Halt Statement</h3>
            <p>The <b>halt</b> statement is used to halt the machine.<br/></p>
				
                    <p><tt><b>SYNTAX : </b><b>halt</b>;</tt></p>
      <p>This statement translates to <a href="../arch_spec-files/instruction_set.html" target="_blank">HALT machine instruction</a>.</p>
                
                <h3>Inline Statement</h3>
				<p>The <b>inline</b> statement is used to give XSM machine instructions directly within an SPL program.<br/></p>
				
					<tt>&nbsp;&nbsp;&nbsp; <b>SYNTAX : </b><b>inline</b> "<i>MACHINE INSTRUCTION</i>";</tt>
					<br/>
            <pre>
            inline "JMP 11776";</pre>  
                            </div>
                          </div>
                        </div>
                    <!--end item 5--> 

<!-- START SINGLE FEATURED ITEM #fun -->
                        <div class="panel panel-default ">
                          <div class="panel-heading">
                            <h4 class="panel-title">
                              <a data-toggle="collapse" href="#fun">
                                <span class="fa fa-check-square-o"></span>Functions
                              </a>
                            </h4>
                          </div>
                          <div id="fun" class="panel-collapse collapse">
                            <div class="panel-body">
                            <p>SPL does not provide explicit support for functions. However, a label can be defined at the beginning of the code for a function and the code can be invoked using the <b>call</b> instruction using the label. This allows use of functions inside a module. Labels defined in one module will not be visible in other modules.</p>

<p>If parameters are to be passed to a function, it has to be explictly passed either using agreed upon registers or variables defined in the module or using a stack.</p>

                                <p>A function loaded at a particular known location in memory (either specified directly by the memory address or using a pre-defined constant) can be invoked by a call to the corresponding memory address. However, it is recommended to follow the conventions discussed below in inter-module calls. Note that in this case, arguments can be only passed through the stack because variables defined in one module will not be visible in other modules.</p> 
                                

<pre>call swap;
call MOD_4;
call 511;  /* Transfers control to the first page in memory */  </pre>     

                                    
                            </div>
                          </div>
                        </div>
                    <!--end item fun-->  

<!-- START SINGLE FEATURED ITEM #con -->
                        <div class="panel panel-default ">
                          <div class="panel-heading">
                            <h4 class="panel-title">
                              <a data-toggle="collapse" href="#con">
                                <span class="fa fa-check-square-o"></span>SPL Module Programming Conventions
                              </a>
                            </h4>
                          </div>
                          <div id="con" class="panel-collapse collapse">
                            <div class="panel-body">
                                <p>Each SPL module is designed to occupy a maximum of two pages of continuous memory in the XSM machine. A module typically contains protected mode code that carries out certain functions as determined by the programmer. The following suggests certain programming conventions which are recommend while designing SPL modules.</p>

                                <p><span class="label label-success label-as-badge">1</span> Each module shall be designed to have a single entry point, which is generally the starting memory address of the module in memory. It is not recommended to transfer control directly into a location within a module from other modules.</p>

                                <p><span class="label label-success label-as-badge">2</span> Arguments to a module (typically includes the function code indicating which function within the module is to be invoked, as well as the parameters to that function) shall be passed through the stack. The return value may also be passed through the stack. A recommended parameter passing convention is shown in the figure below:</p>
                                    
                                <center>                        <img src="../img/memory_management.png"></center>
                                <p><code>Note: </code> The SPL compiler given here predefines eXpOS specific constants MOD_0 to MOD_7 as starting address of eXpOS kernel modules, which are (optionally) loaded into various pre-defined memory pages of the XSM machine when eXpOS starts up). In addition to these, all interrupt service routines can be programmed as SPL modules are loaded to the corresponding interrupt service routine locations in memory. The SPL predefined constants INT_0 to INT_18 can be used to invoke these modules.</p>
 
                                <p><span class="label label-success label-as-badge">3</span> A module may be entered as a result of: <br/>
                               <div style="padding-left:70px"> a. Execution of a software interrupt from an application (unprotected mode) program.<br/>
                                b. Hardware interrupt/exception occurred while an application was executing.<br/>
                                c. Call from another module.<br/>
                                </div>
                                   </p>

                                <p><b>Case a)</b> In this case, the arguments to the module are typically passed through the application stack. The convention is that the application must save the state of its registers before making the call. (For instance, the eXpL compiler will save the context in the user stack before invoking a software interrupt). Thus, the interrupt routine need not concern itself about saving the context of the application and can use the registers R0-R15 without saving them. However, the application is not expected to save SP, BP registers before the call, and the module must save them for future return.</p>

                              <p><b>However, in this case, it is strongly recommended that the module allocates its own stack in the memory and not use the application's stack.</b> This is to avoid potential user level “hacks” into protected mode interrupt modules through the stack.</p>

                                <p><b>Case b)</b> This case applies to the exception handler, timer interrupt routine, disk interrupt routine and the console interrupt routine. The difference here from case a) is that the application does not have control over the transfer of control, and hence would not have saved its context. Thus, in this case, the module must save the register context of the application in its own stack (or elsewhere in the memory) before using the registers and must restore the context before returning to the application.</p>

                                <p><b>Case c)</b> In this case, since the caller and the callee are both executing in protected mode, the same stack can be used. The recommended convention is that the caller must save its register context into the stack before making the call.</p> 
                            </div>
                          </div>
                        </div>
                    <!--end item con-->    
      
                    
                      </div>
                    </div>
                </div>
              </div>
            </div>
          </div>
        </div>       
      </div>
       </section>
   
		   
      <!--=========== BEGIN FOOTER ================-->
     <footer id="footer">
       <div class="container">
         <div class="row">
           <div class="col-lg-6 col-md-6 col-sm-6">
             <div class="footer_left">
               <p><a href="http://www.nitc.ac.in/">National Institute of Technology, Calicut</a></p>
             </div>
           </div>
         </div>
       </div>
      </footer>
      <!--=========== END FOOTER ================-->

     <!-- Javascript Files
     ================================================== -->
  
     <!-- initialize jQuery Library -->
    <script src="../js/jquery.min.js"></script>
    <!-- Google map -->
    <script src="../js/map_js.js"></script>
    <script src="../js/jquery.ui.map.js"></script>
     <!-- For smooth animatin  -->
    <script src="../js/wow.min.js"></script> 
    <!-- Bootstrap js -->
    <script src="../js/bootstrap.min.js"></script>
    <!-- superslides slider -->
    <script src="../js/jquery.superslides.min.js" type="text/javascript"></script>
    <!-- slick slider -->
    <script src="../js/slick.min.js"></script>    
    <!-- for circle counter -->
    <script src='../js/jquery.circliful.min.js'></script>
    <!-- for portfolio filter gallery -->
    <script src="../js/modernizr.custom.js"></script>
    <script src="../js/classie.js"></script>
    <script src="../js/elastic_grid.min.js"></script>
    <script src="../js/portfolio_slider.js"></script>

    <!-- Custom js-->
    <script src="../js/custom.js"></script>
  </body>
</html>

