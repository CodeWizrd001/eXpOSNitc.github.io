<!DOCTYPE html>
<html>
<head>
  <title>The fundamental eXpOS Abstractions</title>
</head>

<body> <h1>The fundamental eXpOS Abstractions</h1> 
<div><p>eXpOS provides the following fundamental abstractions to an application program: </p>
<ol>
	<li>The eXpFS logical <i>file system</i></li>
	<li>The <i>process</i> abstraction for programs in execution</li>
	<li>Methods of resource sharing</li>
	<li>Primitives for concurrent access control and  process synchronization</li>
	<li>The <b>system call interface</b> that specifies the interface through which application programs can invoke the system calls and access the OS services.  </li>
</ol>
</div>
<div><h3>The eXpFS logical file system.  </h3>
<p>The eXpOS kernal provides a hardware independent logical file system model (called the <b>experimental file system or eXpFS</b>) for the application programs.       The application program views files as being organized and stored in the eXpFS logical file system.  Application programs are not permitted to access files directly.  Instead, they must invoke the appropriate <b>file system call</b> for creating, modifying or accessing files.   The OS routine implementing each system call internally translates the request into disk block operations, hiding the hardware details from the application program.</p>
<p>XFS support three kinds of files – <b>data files, program files </b> (executable files) and a special file called the <b>root file. </b> The root file is a meta-data file that contains the list of all files in the file system.  A data file consists of a sequence of words.  A program contains the sequence of machine instructions of the program together with the static data of the program and a header. </p>
<p>eXpOS does not provide any mechanisms for application programs to create <b>executable files</b>.    Executable files have to be pre-loaded into the disk using some other external disk access mechanism before OS bootstrap.   Since such mechanisms are implementation dependent, they are not part of the OS specification.  For instance, the <a href="xfs_interface.html">XFS-Interface</a> tool for eXpOS implementation on the XSM machine is one such mechanism. </p>
<p>Executable files follow certain format called the <b>experimental executable format or XEXE format</b>.  The OS will execute only program files stored in the file system in the XEXE format.  Hence system programs like compilers that translate high level application programs must ensure that the executable files adhere to the XEXE format.  </p>
<p>Application programs can create, modify and delete data files using appropriate OS system calls.  These are discussed <a href="#System_calls">here</a>.</p>
<p>A detailed discussion of the file system structure, file system calls and XEXE format is given in <a href="eXpfs.html">Section</a>.</p>
</div>
<div><h3>The eXpOS process Abstraction</h3>
<p>It was noted earlier that at the end of bootstrap, eXpOS loads into memory a program stored in a pre-determined part of the disk and create the first process called the INIT process.  Once a process is created, it can spawn new processes using the <b>fork </b> system call.    When a process spawns a new process, the former is called the <b>parent process</b> and the later is called the <b>child process</b>.  A process can decide to terminate itself using the <b>exit</b> system call.  </p>
<p>Associated with each process, there is a (virtual) address space (or logical memory space).  This address space is a sequence of memory locations, each of which can store a word.    XOS logically divides the address space of a process is into four regions – (shared) library, code, stack and heap. </p>
<p>When a process is created using the fork system call, the OS creates a virtual address space for the new process.   Each process is given a view that it has its own virtual address space containing its code, data, library, stack and heap.  The virtual address space is a continuous address space starting from address 0 up to a maximum limit that is implementation dependent.  Internally, the OS maps the virtual address space into the machine memory using hardware mechanisms available in the machine like paging/segmentation.( Check mapping <a href="paging_translation.html">here</a>)</p>
<p>The code region of a process contains the machine instructions that are to be executed.    This code consists of the instructions stored in some executable file in the file system. When a new process is created using the fork system call, the child process shares the library, code and heap with the parent.  This means that any modifications to memory words in these regions by one process will result in modification of the contents for both processes.  The stack and the data regions of the parent and the child will be separate. The parent and the child concurrently proceeds execution from the instruction immediately after the fork system call in the code. </p>
<p>The stack and the data regions of a process stores the variables (including static variables) and stack frames during the execution of the program.   Dynamic memory allocation is normally done from the heap region.  Variables to be shared between different processes could also be allocated in the heap.   Finally all (standard) library code (which is typically shared by all applications) is mapped to the library region.  </p>
<p></p>
</div>
<div id="System_calls">blah blah</div>
</body>
</html> 
